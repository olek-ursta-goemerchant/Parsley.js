{"version":3,"sources":["parsley.min.js","parsley.js","src/parsley/pubsub.js","src/vendor/inputevent.js","src/parsley/utils.js","src/parsley/defaults.js","src/parsley/base.js","src/parsley/validator.js","src/parsley/validator_registry.js","src/parsley/ui.js","src/parsley/form.js","src/parsley/constraint.js","src/parsley/field.js","src/parsley/multiple.js","src/parsley/factory.js","src/parsley/main.js","src/parsley/remote.js","src/i18n/en.js","src/parsley.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_slice","prototype","slice","_slicedToArray","sliceIterator","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","err","Object","TypeError","_extends","assign","target","arguments","source","key","hasOwnProperty","call","global","factory","exports","module","require","define","amd","parsley","jQuery","this","$","adapt","fn","context","parsleyAdaptedCallback","args","unshift","apply","o","eventName","name","lastIndexOf","eventPrefix","substr","InputEvent","_this14","globals","window","isNativeEvent","evt","originalEvent","isTrusted","fakeInputEvent","trigger","misbehaves","behavesOk","document","on","data","selector","off","install","inputEventPatched","uninstall","globalID","pastWarnings","Utils","attr","element","namespace","obj","attribute","attributes","regex","RegExp","specified","test","camelize","deserializeValue","checkAttr","_checkAttr","hasAttribute","setAttr","setAttribute","dasherize","String","generateID","num","isNaN","Number","parseJSON","e","str","replace","match","chr","toUpperCase","toLowerCase","warn","_window$console","console","warnOnce","msg","_resetWarnings","trimString","string","parse","date","parsed","_parsed$map","map","x","parseInt","_parsed$map2","year","month","day","Date","getFullYear","getMonth","getDate","_string","integer","number","parseFloat","boolean","object","regexp","_regexp","flags","parseRequirement","requirementType","converter","converted","namespaceEvents","events","split","join","difference","array","remove","result","each","_","elem","indexOf","all","promises","when","concat","objectCreate","create","Error","_SubmitSelector","Defaults","inputs","excluded","priorityEnabled","multiple","group","uiEnabled","validationThreshold","focus","triggerAfterFailure","errorClass","successClass","classHandler","Field","errorsContainer","errorsWrapper","errorTemplate","Base","__id__","asyncSupport","_pipeAccordingToValidationResult","_this","pipe","r","Deferred","validationResult","reject","resolve","promise","actualizeOptions","options","domOptions","parent","_resetOptions","initOptions","_listeners","queue","subscribe","listenTo","splice","unsubscribe","unsubscribeTo","extraArg","asyncIsValid","force","whenValid","_findRelated","querySelectorAll","$element","convertArrayRequirement","m","values","convertExtraOptionRequirement","requirementSpec","extraOptionReader","main","extra","Validator","spec","extend","validate","requirementFirstArg","validateMultiple","instance","validateDate","_isDateInput","validateNumber","validateString","parseRequirements","requirements","type","isPlainObject","priority","ValidatorRegistry","validators","catalog","__class__","locale","init","typeTesters","email","digits","alphanum","url","range","decimalPlaces","Math","max","ValidatorRegistry__parseArguments","ValidatorRegistry__operatorToValidator","operator","_len","requirementsAndInput","_key","pop","ValidatorRegistry__comparisonOperator","addValidator","Parsley","setLocale","addCatalog","messages","set","addMessage","message","addMessages","nameMessageObject","arg1","arg2","_setValidator","updateValidator","removeValidator","validator","getErrorMessage","constraint","typeMessages","formatMessage","defaultMessage","en","parameters","notblank","required","_ref","_ref$step","step","_ref$base","base","tester","nb","decimals","toInt","f","round","pow","","pattern","minlength","requirement","maxlength","min","mincheck","maxcheck","check","equalto","refOrValue","$reference","val","UI","diffResults","newResult","oldResult","deep","added","kept","found","j","assert","removed","Form","_actualizeTriggers","_this2","onSubmitValidate","onSubmitButton","_focusedField","fields","field","noFocus","_destroyUI","_reflowUI","_ref2","silent","_buildUI","_ui","diff","lastValidationResult","_manageStatusClass","_manageErrorsMessages","_failedOnce","getErrorsMessages","errorMessage","_getErrorMessage","addError","_ref3","_ref3$updateClass","updateClass","_addError","_errorClass","updateError","_ref4","_ref4$updateClass","_updateError","removeError","_ref5","_ref5$updateClass","_removeError","hasConstraints","needsValidation","_successClass","_resetClass","errorsMessagesDisabled","_insertErrorWrapper","$errorsWrapper","find","append","addClass","html","removeClass","_ref6","_ref7","customConstraintErrorMessage","$errorClassHandler","_manageClassHandler","errorsWrapperId","validationInformationVisible","ParsleyUtils","$handler","_inputHolder","nodeName","$errorsContainer","after","_this3","$toBind","_validateIfNeeded","event","_this4","getValue","debounce","clearTimeout","_debounced","setTimeout","_resetUI","children","Form__statusMapping","pending","resolved","rejected","_this5","submitSource","_submitSource","prop","getAttribute","_remoteCache","whenValidate","state","_trigger","stopImmediatePropagation","preventDefault","_submit","currentTarget","$synthetic","appendTo","Event","_arguments","_Utils$all$done$fail$always","_this6","_ref8","submitEvent","_refreshFields","_withoutReactualizingFormOptions","fail","always","isValid","_arguments2","_this7","_ref9","reset","destroy","removeData","_bindFields","_this8","oldFields","fieldsMappedById","not","fieldInstance","Factory","uniqueId","oldActualizeOptions","Constraint","parsleyField","isDomConstraint","validatorSpec","_validatorRegistry","_parseRequirements","capitalize","cap","_validator","requirementList","_this9","parsleyFormInstance","constraints","constraintsByName","_bindConstraints","parsley_field__statusMapping","_whenValid$always$done$fail$always","_this10","_ref10","refreshConstraints","_isInGroup","_refreshed","_isRequired","validateIfEmpty","inArray","_arguments3","_this11","_ref11","_ref11$force","groupedConstraints","_getGroupedConstraints","_validateConstraint","_this12","_handleWhitespace","addConstraint","removeConstraint","updateConstraint","_bindHtml5Constraints","trimValue","whitespace","c","index","p","sort","a","b","parsley_field","Multiple","addElement","$elements","fieldConstraints","has","filter","_init","savedparsleyFormInstance","__version__","is","bind","isMultiple","handleMultiple","parsleyMultipleInstance","_this13","input","$previouslyRelated","get","doNotStore","parsleyInstance","ParsleyExtend","vernums","jquery","forEach","version","psly","instances","ParsleyConfig","registry","i18n","ParsleyValidator","method","_window$Parsley","ParsleyUI","doNotUpdateClass","autoBind","deprecated","listen","callback","unsubscribeAll","emit","_instance","instanceGiven","asyncValidators","default","xhr","status","reverse","addAsyncValidator","ajaxOptions","csr","encodeURIComponent","remoteOptions","param","ajax","handleXhr","then","inputevent"],"mappings":"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","file":"parsley.min.js","sourcesContent":["/*!\r\n* Parsley.js\r\n* Version 2.7.3 - built Fri, May 19th 2017, 10:29 am\r\n* http://parsleyjs.org\r\n* Guillaume Potier - <guillaume@wisembly.com>\r\n* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>\r\n* MIT Licensed\r\n*/\r\n\r\n// The source code below is generated by babel as\r\n// Parsley is written in ECMAScript 6\r\n//\r\nvar _slice = Array.prototype.slice;\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery')) : typeof define === 'function' && define.amd ? define(['jquery'], factory) : global.parsley = factory(global.jQuery);\n})(this, function ($) {\n  'use strict';\n\n  var globalID = 1;\n  var pastWarnings = {};\n\n  var Utils = {\n    // Parsley DOM-API\n    // returns object from dom attributes and values\n    attr: function attr(element, namespace, obj) {\n      var i;\n      var attribute;\n      var attributes;\n      var regex = new RegExp('^' + namespace, 'i');\n\n      if ('undefined' === typeof obj) obj = {};else {\n        // Clear all own properties. This won't affect prototype's values\n        for (i in obj) {\n          if (obj.hasOwnProperty(i)) delete obj[i];\n        }\n      }\n\n      if (!element) return obj;\n\n      attributes = element.attributes;\n      for (i = attributes.length; i--;) {\n        attribute = attributes[i];\n\n        if (attribute && attribute.specified && regex.test(attribute.name)) {\n          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n        }\n      }\n\n      return obj;\n    },\n\n    checkAttr: function checkAttr(element, namespace, _checkAttr) {\n      return element.hasAttribute(namespace + _checkAttr);\n    },\n\n    setAttr: function setAttr(element, namespace, attr, value) {\n      element.setAttribute(this.dasherize(namespace + attr), String(value));\n    },\n\n    generateID: function generateID() {\n      return '' + globalID++;\n    },\n\n    /** Third party functions **/\n    // Zepto deserialize function\n    deserializeValue: function deserializeValue(value) {\n      var num;\n\n      try {\n        return value ? value == \"true\" || (value == \"false\" ? false : value == \"null\" ? null : !isNaN(num = Number(value)) ? num : /^[\\[\\{]/.test(value) ? $.parseJSON(value) : value) : value;\n      } catch (e) {\n        return value;\n      }\n    },\n\n    // Zepto camelize function\n    camelize: function camelize(str) {\n      return str.replace(/-+(.)?/g, function (match, chr) {\n        return chr ? chr.toUpperCase() : '';\n      });\n    },\n\n    // Zepto dasherize function\n    dasherize: function dasherize(str) {\n      return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();\n    },\n\n    warn: function warn() {\n      var _window$console;\n\n      if (window.console && 'function' === typeof window.console.warn) (_window$console = window.console).warn.apply(_window$console, arguments);\n    },\n\n    warnOnce: function warnOnce(msg) {\n      if (!pastWarnings[msg]) {\n        pastWarnings[msg] = true;\n        this.warn.apply(this, arguments);\n      }\n    },\n\n    _resetWarnings: function _resetWarnings() {\n      pastWarnings = {};\n    },\n\n    trimString: function trimString(string) {\n      return string.replace(/^\\s+|\\s+$/g, '');\n    },\n\n    parse: {\n      date: function date(string) {\n        var parsed = string.match(/^(\\d{4,})-(\\d\\d)-(\\d\\d)$/);\n        if (!parsed) return null;\n\n        var _parsed$map = parsed.map(function (x) {\n          return parseInt(x, 10);\n        });\n\n        var _parsed$map2 = _slicedToArray(_parsed$map, 4);\n\n        var _ = _parsed$map2[0];\n        var year = _parsed$map2[1];\n        var month = _parsed$map2[2];\n        var day = _parsed$map2[3];\n\n        var date = new Date(year, month - 1, day);\n        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) return null;\n        return date;\n      },\n      string: function string(_string) {\n        return _string;\n      },\n      integer: function integer(string) {\n        if (isNaN(string)) return null;\n        return parseInt(string, 10);\n      },\n      number: function number(string) {\n        if (isNaN(string)) throw null;\n        return parseFloat(string);\n      },\n      'boolean': function _boolean(string) {\n        return !/^\\s*false\\s*$/i.test(string);\n      },\n      object: function object(string) {\n        return Utils.deserializeValue(string);\n      },\n      regexp: function regexp(_regexp) {\n        var flags = '';\n\n        // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n        if (/^\\/.*\\/(?:[gimy]*)$/.test(_regexp)) {\n          // Replace the regexp literal string with the first match group: ([gimy]*)\n          // If no flag is present, this will be a blank string\n          flags = _regexp.replace(/.*\\/([gimy]*)$/, '$1');\n          // Again, replace the regexp literal string with the first match group:\n          // everything excluding the opening and closing slashes and the flags\n          _regexp = _regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n        } else {\n          // Anchor regexp:\n          _regexp = '^' + _regexp + '$';\n        }\n        return new RegExp(_regexp, flags);\n      }\n    },\n\n    parseRequirement: function parseRequirement(requirementType, string) {\n      var converter = this.parse[requirementType || 'string'];\n      if (!converter) throw 'Unknown requirement specification: \"' + requirementType + '\"';\n      var converted = converter(string);\n      if (converted === null) throw 'Requirement is not a ' + requirementType + ': \"' + string + '\"';\n      return converted;\n    },\n\n    namespaceEvents: function namespaceEvents(events, namespace) {\n      events = this.trimString(events || '').split(/\\s+/);\n      if (!events[0]) return '';\n      return $.map(events, function (evt) {\n        return evt + '.' + namespace;\n      }).join(' ');\n    },\n\n    difference: function difference(array, remove) {\n      // This is O(N^2), should be optimized\n      var result = [];\n      $.each(array, function (_, elem) {\n        if (remove.indexOf(elem) == -1) result.push(elem);\n      });\n      return result;\n    },\n\n    // Alter-ego to native Promise.all, but for jQuery\n    all: function all(promises) {\n      // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\n      return $.when.apply($, _toConsumableArray(promises).concat([42, 42]));\n    },\n\n    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n    objectCreate: Object.create || (function () {\n      var Object = function Object() {};\n      return function (prototype) {\n        if (arguments.length > 1) {\n          throw Error('Second argument not supported');\n        }\n        if (typeof prototype != 'object') {\n          throw TypeError('Argument must be an object');\n        }\n        Object.prototype = prototype;\n        var result = new Object();\n        Object.prototype = null;\n        return result;\n      };\n    })(),\n\n    _SubmitSelector: 'input[type=\"submit\"], button:submit'\n  };\n\n  // All these options could be overriden and specified directly in DOM using\n  // `data-parsley-` default DOM-API\n  // eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n  // eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\n  var Defaults = {\n    // ### General\n\n    // Default data-namespace for DOM API\n    namespace: 'data-parsley-',\n\n    // Supported inputs by default\n    inputs: 'input, textarea, select',\n\n    // Excluded inputs by default\n    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n    // Stop validating field on highest priority failing constraint\n    priorityEnabled: true,\n\n    // ### Field only\n\n    // identifier used to group together inputs (e.g. radio buttons...)\n    multiple: null,\n\n    // identifier (or array of identifiers) used to validate only a select group of inputs\n    group: null,\n\n    // ### UI\n    // Enable\\Disable error messages\n    uiEnabled: true,\n\n    // Key events threshold before validation\n    validationThreshold: 3,\n\n    // Focused field on form validation error. 'first'|'last'|'none'\n    focus: 'first',\n\n    // event(s) that will trigger validation before first failure. eg: `input`...\n    trigger: false,\n\n    // event(s) that will trigger validation after first failure.\n    triggerAfterFailure: 'input',\n\n    // Class that would be added on every failing validation Parsley field\n    errorClass: 'parsley-error',\n\n    // Same for success validation\n    successClass: 'parsley-success',\n\n    // Return the `$element` that will receive these above success or error classes\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    classHandler: function classHandler(Field) {},\n\n    // Return the `$element` where errors will be appended\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    errorsContainer: function errorsContainer(Field) {},\n\n    // ul elem that would receive errors' list\n    errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n    // li elem that would receive error message\n    errorTemplate: '<li></li>'\n  };\n\n  var Base = function Base() {\n    this.__id__ = Utils.generateID();\n  };\n\n  Base.prototype = {\n    asyncSupport: true, // Deprecated\n\n    _pipeAccordingToValidationResult: function _pipeAccordingToValidationResult() {\n      var _this = this;\n\n      var pipe = function pipe() {\n        var r = $.Deferred();\n        if (true !== _this.validationResult) r.reject();\n        return r.resolve().promise();\n      };\n      return [pipe, pipe];\n    },\n\n    actualizeOptions: function actualizeOptions() {\n      Utils.attr(this.element, this.options.namespace, this.domOptions);\n      if (this.parent && this.parent.actualizeOptions) this.parent.actualizeOptions();\n      return this;\n    },\n\n    _resetOptions: function _resetOptions(initOptions) {\n      this.domOptions = Utils.objectCreate(this.parent.options);\n      this.options = Utils.objectCreate(this.domOptions);\n      // Shallow copy of ownProperties of initOptions:\n      for (var i in initOptions) {\n        if (initOptions.hasOwnProperty(i)) this.options[i] = initOptions[i];\n      }\n      this.actualizeOptions();\n    },\n\n    _listeners: null,\n\n    // Register a callback for the given event name\n    // Callback is called with context as the first argument and the `this`\n    // The context is the current parsley instance, or window.Parsley if global\n    // A return value of `false` will interrupt the calls\n    on: function on(name, fn) {\n      this._listeners = this._listeners || {};\n      var queue = this._listeners[name] = this._listeners[name] || [];\n      queue.push(fn);\n\n      return this;\n    },\n\n    // Deprecated. Use `on` instead\n    subscribe: function subscribe(name, fn) {\n      $.listenTo(this, name.toLowerCase(), fn);\n    },\n\n    // Unregister a callback (or all if none is given) for the given event name\n    off: function off(name, fn) {\n      var queue = this._listeners && this._listeners[name];\n      if (queue) {\n        if (!fn) {\n          delete this._listeners[name];\n        } else {\n          for (var i = queue.length; i--;) if (queue[i] === fn) queue.splice(i, 1);\n        }\n      }\n      return this;\n    },\n\n    // Deprecated. Use `off`\n    unsubscribe: function unsubscribe(name, fn) {\n      $.unsubscribeTo(this, name.toLowerCase());\n    },\n\n    // Trigger an event of the given name\n    // A return value of `false` interrupts the callback chain\n    // Returns false if execution was interrupted\n    trigger: function trigger(name, target, extraArg) {\n      target = target || this;\n      var queue = this._listeners && this._listeners[name];\n      var result;\n      var parentResult;\n      if (queue) {\n        for (var i = queue.length; i--;) {\n          result = queue[i].call(target, target, extraArg);\n          if (result === false) return result;\n        }\n      }\n      if (this.parent) {\n        return this.parent.trigger(name, target, extraArg);\n      }\n      return true;\n    },\n\n    asyncIsValid: function asyncIsValid(group, force) {\n      Utils.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\n      return this.whenValid({ group: group, force: force });\n    },\n\n    _findRelated: function _findRelated() {\n      return this.options.multiple ? $(this.parent.element.querySelectorAll('[' + this.options.namespace + 'multiple=\"' + this.options.multiple + '\"]')) : this.$element;\n    }\n  };\n\n  var convertArrayRequirement = function convertArrayRequirement(string, length) {\n    var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n    if (!m) throw 'Requirement is not an array: \"' + string + '\"';\n    var values = m[1].split(',').map(Utils.trimString);\n    if (values.length !== length) throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n    return values;\n  };\n\n  var convertExtraOptionRequirement = function convertExtraOptionRequirement(requirementSpec, string, extraOptionReader) {\n    var main = null;\n    var extra = {};\n    for (var key in requirementSpec) {\n      if (key) {\n        var value = extraOptionReader(key);\n        if ('string' === typeof value) value = Utils.parseRequirement(requirementSpec[key], value);\n        extra[key] = value;\n      } else {\n        main = Utils.parseRequirement(requirementSpec[key], string);\n      }\n    }\n    return [main, extra];\n  };\n\n  // A Validator needs to implement the methods `validate` and `parseRequirements`\n\n  var Validator = function Validator(spec) {\n    $.extend(true, this, spec);\n  };\n\n  Validator.prototype = {\n    // Returns `true` iff the given `value` is valid according the given requirements.\n    validate: function validate(value, requirementFirstArg) {\n      if (this.fn) {\n        // Legacy style validator\n\n        if (arguments.length > 3) // If more args then value, requirement, instance...\n          requirementFirstArg = [].slice.call(arguments, 1, -1); // Skip first arg (value) and last (instance), combining the rest\n        return this.fn(value, requirementFirstArg);\n      }\n\n      if (Array.isArray(value)) {\n        if (!this.validateMultiple) throw 'Validator `' + this.name + '` does not handle multiple values';\n        return this.validateMultiple.apply(this, arguments);\n      } else {\n        var instance = arguments[arguments.length - 1];\n        if (this.validateDate && instance._isDateInput()) {\n          arguments[0] = Utils.parse.date(arguments[0]);\n          if (arguments[0] === null) return false;\n          return this.validateDate.apply(this, arguments);\n        }\n        if (this.validateNumber) {\n          if (isNaN(value)) return false;\n          arguments[0] = parseFloat(arguments[0]);\n          return this.validateNumber.apply(this, arguments);\n        }\n        if (this.validateString) {\n          return this.validateString.apply(this, arguments);\n        }\n        throw 'Validator `' + this.name + '` only handles multiple values';\n      }\n    },\n\n    // Parses `requirements` into an array of arguments,\n    // according to `this.requirementType`\n    parseRequirements: function parseRequirements(requirements, extraOptionReader) {\n      if ('string' !== typeof requirements) {\n        // Assume requirement already parsed\n        // but make sure we return an array\n        return Array.isArray(requirements) ? requirements : [requirements];\n      }\n      var type = this.requirementType;\n      if (Array.isArray(type)) {\n        var values = convertArrayRequirement(requirements, type.length);\n        for (var i = 0; i < values.length; i++) values[i] = Utils.parseRequirement(type[i], values[i]);\n        return values;\n      } else if ($.isPlainObject(type)) {\n        return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n      } else {\n        return [Utils.parseRequirement(type, requirements)];\n      }\n    },\n    // Defaults:\n    requirementType: 'string',\n\n    priority: 2\n\n  };\n\n  var ValidatorRegistry = function ValidatorRegistry(validators, catalog) {\n    this.__class__ = 'ValidatorRegistry';\n\n    // Default Parsley locale is en\n    this.locale = 'en';\n\n    this.init(validators || {}, catalog || {});\n  };\n\n  var typeTesters = {\n    email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n    // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\n    number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\n\n    integer: /^-?\\d+$/,\n\n    digits: /^\\d+$/,\n\n    alphanum: /^\\w+$/i,\n\n    date: {\n      test: function test(value) {\n        return Utils.parse.date(value) !== null;\n      }\n    },\n\n    url: new RegExp(\"^\" +\n    // protocol identifier\n    \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n    // user:pass authentication\n    \"(?:\\\\S+(?::\\\\S*)?@)?\" + \"(?:\" +\n    // IP address exclusion\n    // private & local networks\n    // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n    // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n    // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n    // IP address dotted notation octets\n    // excludes loopback network 0.0.0.0\n    // excludes reserved space >= 224.0.0.0\n    // excludes network & broacast addresses\n    // (first & last IP address of each class)\n    \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" + \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" + \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" + \"|\" +\n    // host name\n    '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)' +\n    // domain name\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*' +\n    // TLD identifier\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))' + \")\" +\n    // port number\n    \"(?::\\\\d{2,5})?\" +\n    // resource path\n    \"(?:/\\\\S*)?\" + \"$\", 'i')\n  };\n  typeTesters.range = typeTesters.number;\n\n  // See http://stackoverflow.com/a/10454560/8279\n  var decimalPlaces = function decimalPlaces(num) {\n    var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) {\n      return 0;\n    }\n    return Math.max(0,\n    // Number of digits right of decimal point.\n    (match[1] ? match[1].length : 0) - (\n    // Adjust for scientific notation.\n    match[2] ? +match[2] : 0));\n  };\n\n  // parseArguments('number', ['1', '2']) => [1, 2]\n  var ValidatorRegistry__parseArguments = function ValidatorRegistry__parseArguments(type, args) {\n    return args.map(Utils.parse[type]);\n  };\n  // operatorToValidator returns a validating function for an operator function, applied to the given type\n  var ValidatorRegistry__operatorToValidator = function ValidatorRegistry__operatorToValidator(type, operator) {\n    return function (value) {\n      for (var _len = arguments.length, requirementsAndInput = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        requirementsAndInput[_key - 1] = arguments[_key];\n      }\n\n      requirementsAndInput.pop(); // Get rid of `input` argument\n      return operator.apply(undefined, [value].concat(_toConsumableArray(ValidatorRegistry__parseArguments(type, requirementsAndInput))));\n    };\n  };\n\n  var ValidatorRegistry__comparisonOperator = function ValidatorRegistry__comparisonOperator(operator) {\n    return {\n      validateDate: ValidatorRegistry__operatorToValidator('date', operator),\n      validateNumber: ValidatorRegistry__operatorToValidator('number', operator),\n      requirementType: operator.length <= 2 ? 'string' : ['string', 'string'], // Support operators with a 1 or 2 requirement(s)\n      priority: 30\n    };\n  };\n\n  ValidatorRegistry.prototype = {\n    init: function init(validators, catalog) {\n      this.catalog = catalog;\n      // Copy prototype's validators:\n      this.validators = _extends({}, this.validators);\n\n      for (var name in validators) this.addValidator(name, validators[name].fn, validators[name].priority);\n\n      window.Parsley.trigger('parsley:validator:init');\n    },\n\n    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n    setLocale: function setLocale(locale) {\n      if ('undefined' === typeof this.catalog[locale]) throw new Error(locale + ' is not available in the catalog');\n\n      this.locale = locale;\n\n      return this;\n    },\n\n    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n    addCatalog: function addCatalog(locale, messages, set) {\n      if ('object' === typeof messages) this.catalog[locale] = messages;\n\n      if (true === set) return this.setLocale(locale);\n\n      return this;\n    },\n\n    // Add a specific message for a given constraint in a given locale\n    addMessage: function addMessage(locale, name, message) {\n      if ('undefined' === typeof this.catalog[locale]) this.catalog[locale] = {};\n\n      this.catalog[locale][name] = message;\n\n      return this;\n    },\n\n    // Add messages for a given locale\n    addMessages: function addMessages(locale, nameMessageObject) {\n      for (var name in nameMessageObject) this.addMessage(locale, name, nameMessageObject[name]);\n\n      return this;\n    },\n\n    // Add a new validator\n    //\n    //    addValidator('custom', {\n    //        requirementType: ['integer', 'integer'],\n    //        validateString: function(value, from, to) {},\n    //        priority: 22,\n    //        messages: {\n    //          en: \"Hey, that's no good\",\n    //          fr: \"Aye aye, pas bon du tout\",\n    //        }\n    //    })\n    //\n    // Old API was addValidator(name, function, priority)\n    //\n    addValidator: function addValidator(name, arg1, arg2) {\n      if (this.validators[name]) Utils.warn('Validator \"' + name + '\" is already defined.');else if (Defaults.hasOwnProperty(name)) {\n        Utils.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n        return;\n      }\n      return this._setValidator.apply(this, arguments);\n    },\n\n    updateValidator: function updateValidator(name, arg1, arg2) {\n      if (!this.validators[name]) {\n        Utils.warn('Validator \"' + name + '\" is not already defined.');\n        return this.addValidator.apply(this, arguments);\n      }\n      return this._setValidator.apply(this, arguments);\n    },\n\n    removeValidator: function removeValidator(name) {\n      if (!this.validators[name]) Utils.warn('Validator \"' + name + '\" is not defined.');\n\n      delete this.validators[name];\n\n      return this;\n    },\n\n    _setValidator: function _setValidator(name, validator, priority) {\n      if ('object' !== typeof validator) {\n        // Old style validator, with `fn` and `priority`\n        validator = {\n          fn: validator,\n          priority: priority\n        };\n      }\n      if (!validator.validate) {\n        validator = new Validator(validator);\n      }\n      this.validators[name] = validator;\n\n      for (var locale in validator.messages || {}) this.addMessage(locale, name, validator.messages[locale]);\n\n      return this;\n    },\n\n    getErrorMessage: function getErrorMessage(constraint) {\n      var message;\n\n      // Type constraints are a bit different, we have to match their requirements too to find right error message\n      if ('type' === constraint.name) {\n        var typeMessages = this.catalog[this.locale][constraint.name] || {};\n        message = typeMessages[constraint.requirements];\n      } else message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n    },\n\n    // Kind of light `sprintf()` implementation\n    formatMessage: function formatMessage(string, parameters) {\n      if ('object' === typeof parameters) {\n        for (var i in parameters) string = this.formatMessage(string, parameters[i]);\n\n        return string;\n      }\n\n      return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\n    },\n\n    // Here is the Parsley default validators list.\n    // A validator is an object with the following key values:\n    //  - priority: an integer\n    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n    // Alternatively, a validator can be a function that returns such an object\n    //\n    validators: {\n      notblank: {\n        validateString: function validateString(value) {\n          return (/\\S/.test(value)\n          );\n        },\n        priority: 2\n      },\n      required: {\n        validateMultiple: function validateMultiple(values) {\n          return values.length > 0;\n        },\n        validateString: function validateString(value) {\n          return (/\\S/.test(value)\n          );\n        },\n        priority: 512\n      },\n      type: {\n        validateString: function validateString(value, type) {\n          var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n          var _ref$step = _ref.step;\n          var step = _ref$step === undefined ? 'any' : _ref$step;\n          var _ref$base = _ref.base;\n          var base = _ref$base === undefined ? 0 : _ref$base;\n\n          var tester = typeTesters[type];\n          if (!tester) {\n            throw new Error('validator type `' + type + '` is not supported');\n          }\n          if (!tester.test(value)) return false;\n          if ('number' === type) {\n            if (!/^any$/i.test(step || '')) {\n              var nb = Number(value);\n              var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\n              if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\n                return false;\n              // Be careful of rounding errors by using integers.\n              var toInt = function toInt(f) {\n                return Math.round(f * Math.pow(10, decimals));\n              };\n              if ((toInt(nb) - toInt(base)) % toInt(step) != 0) return false;\n            }\n          }\n          return true;\n        },\n        requirementType: {\n          '': 'string',\n          step: 'string',\n          base: 'number'\n        },\n        priority: 256\n      },\n      pattern: {\n        validateString: function validateString(value, regexp) {\n          return regexp.test(value);\n        },\n        requirementType: 'regexp',\n        priority: 64\n      },\n      minlength: {\n        validateString: function validateString(value, requirement) {\n          return value.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxlength: {\n        validateString: function validateString(value, requirement) {\n          return value.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      length: {\n        validateString: function validateString(value, min, max) {\n          return value.length >= min && value.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      mincheck: {\n        validateMultiple: function validateMultiple(values, requirement) {\n          return values.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxcheck: {\n        validateMultiple: function validateMultiple(values, requirement) {\n          return values.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      check: {\n        validateMultiple: function validateMultiple(values, min, max) {\n          return values.length >= min && values.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      min: ValidatorRegistry__comparisonOperator(function (value, requirement) {\n        return value >= requirement;\n      }),\n      max: ValidatorRegistry__comparisonOperator(function (value, requirement) {\n        return value <= requirement;\n      }),\n      range: ValidatorRegistry__comparisonOperator(function (value, min, max) {\n        return value >= min && value <= max;\n      }),\n      equalto: {\n        validateString: function validateString(value, refOrValue) {\n          var $reference = $(refOrValue);\n          if ($reference.length) return value === $reference.val();else return value === refOrValue;\n        },\n        priority: 256\n      }\n    }\n  };\n\n  var UI = {};\n\n  var diffResults = function diffResults(newResult, oldResult, deep) {\n    var added = [];\n    var kept = [];\n\n    for (var i = 0; i < newResult.length; i++) {\n      var found = false;\n\n      for (var j = 0; j < oldResult.length; j++) if (newResult[i].assert.name === oldResult[j].assert.name) {\n        found = true;\n        break;\n      }\n\n      if (found) kept.push(newResult[i]);else added.push(newResult[i]);\n    }\n\n    return {\n      kept: kept,\n      added: added,\n      removed: !deep ? diffResults(oldResult, newResult, true).added : []\n    };\n  };\n\n  UI.Form = {\n\n    _actualizeTriggers: function _actualizeTriggers() {\n      var _this2 = this;\n\n      this.$element.on('submit.Parsley', function (evt) {\n        _this2.onSubmitValidate(evt);\n      });\n      this.$element.on('click.Parsley', Utils._SubmitSelector, function (evt) {\n        _this2.onSubmitButton(evt);\n      });\n\n      // UI could be disabled\n      if (false === this.options.uiEnabled) return;\n\n      this.element.setAttribute('novalidate', '');\n    },\n\n    focus: function focus() {\n      this._focusedField = null;\n\n      if (true === this.validationResult || 'none' === this.options.focus) return null;\n\n      for (var i = 0; i < this.fields.length; i++) {\n        var field = this.fields[i];\n        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n          this._focusedField = field.$element;\n          if ('first' === this.options.focus) break;\n        }\n      }\n\n      if (null === this._focusedField) return null;\n\n      return this._focusedField.focus();\n    },\n\n    _destroyUI: function _destroyUI() {\n      // Reset all event listeners\n      this.$element.off('.Parsley');\n    }\n\n  };\n\n  UI.Field = {\n\n    _reflowUI: function _reflowUI() {\n      var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var silent = _ref2.silent;\n\n      this._buildUI();\n\n      // If this field doesn't have an active UI don't bother doing something\n      if (!this._ui) return;\n\n      // Diff between two validation results\n      var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\n\n      // Then store current validation result for next reflow\n      this._ui.lastValidationResult = this.validationResult;\n\n      // Handle valid / invalid / none field class\n      this._manageStatusClass();\n\n      // Add, remove, updated errors messages\n      if (!silent) this._manageErrorsMessages(diff);\n\n      // Triggers impl\n      this._actualizeTriggers();\n\n      // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n      if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\n        this._failedOnce = true;\n        this._actualizeTriggers();\n      }\n    },\n\n    // Returns an array of field's error message(s)\n    getErrorsMessages: function getErrorsMessages() {\n      // No error message, field is valid\n      if (true === this.validationResult) return [];\n\n      var messages = [];\n\n      for (var i = 0; i < this.validationResult.length; i++) messages.push(this.validationResult[i].errorMessage || this._getErrorMessage(this.validationResult[i].assert));\n\n      return messages;\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    addError: function addError(name) {\n      var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var message = _ref3.message;\n      var assert = _ref3.assert;\n      var _ref3$updateClass = _ref3.updateClass;\n      var updateClass = _ref3$updateClass === undefined ? true : _ref3$updateClass;\n\n      this._buildUI();\n      this._addError(name, { message: message, assert: assert });\n\n      if (updateClass) this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    updateError: function updateError(name) {\n      var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var message = _ref4.message;\n      var assert = _ref4.assert;\n      var _ref4$updateClass = _ref4.updateClass;\n      var updateClass = _ref4$updateClass === undefined ? true : _ref4$updateClass;\n\n      this._buildUI();\n      this._updateError(name, { message: message, assert: assert });\n\n      if (updateClass) this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    removeError: function removeError(name) {\n      var _ref5 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var _ref5$updateClass = _ref5.updateClass;\n      var updateClass = _ref5$updateClass === undefined ? true : _ref5$updateClass;\n\n      this._buildUI();\n      this._removeError(name);\n\n      // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\n      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n      if (updateClass) this._manageStatusClass();\n    },\n\n    _manageStatusClass: function _manageStatusClass() {\n      if (this.hasConstraints() && this.needsValidation() && true === this.validationResult) this._successClass();else if (this.validationResult.length > 0) this._errorClass();else this._resetClass();\n    },\n\n    _manageErrorsMessages: function _manageErrorsMessages(diff) {\n      if ('undefined' !== typeof this.options.errorsMessagesDisabled) return;\n\n      // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n      if ('undefined' !== typeof this.options.errorMessage) {\n        if (diff.added.length || diff.kept.length) {\n          this._insertErrorWrapper();\n\n          if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length) this._ui.$errorsWrapper.append($(this.options.errorTemplate).addClass('parsley-custom-error-message'));\n\n          return this._ui.$errorsWrapper.addClass('filled').find('.parsley-custom-error-message').html(this.options.errorMessage);\n        }\n\n        return this._ui.$errorsWrapper.removeClass('filled').find('.parsley-custom-error-message').remove();\n      }\n\n      // Show, hide, update failing constraints messages\n      for (var i = 0; i < diff.removed.length; i++) this._removeError(diff.removed[i].assert.name);\n\n      for (i = 0; i < diff.added.length; i++) this._addError(diff.added[i].assert.name, { message: diff.added[i].errorMessage, assert: diff.added[i].assert });\n\n      for (i = 0; i < diff.kept.length; i++) this._updateError(diff.kept[i].assert.name, { message: diff.kept[i].errorMessage, assert: diff.kept[i].assert });\n    },\n\n    _addError: function _addError(name, _ref6) {\n      var message = _ref6.message;\n      var assert = _ref6.assert;\n\n      this._insertErrorWrapper();\n      this._ui.$errorsWrapper.addClass('filled').append($(this.options.errorTemplate).addClass('parsley-' + name).html(message || this._getErrorMessage(assert)));\n    },\n\n    _updateError: function _updateError(name, _ref7) {\n      var message = _ref7.message;\n      var assert = _ref7.assert;\n\n      this._ui.$errorsWrapper.addClass('filled').find('.parsley-' + name).html(message || this._getErrorMessage(assert));\n    },\n\n    _removeError: function _removeError(name) {\n      this._ui.$errorsWrapper.removeClass('filled').find('.parsley-' + name).remove();\n    },\n\n    _getErrorMessage: function _getErrorMessage(constraint) {\n      var customConstraintErrorMessage = constraint.name + 'Message';\n\n      if ('undefined' !== typeof this.options[customConstraintErrorMessage]) return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\n\n      return window.Parsley.getErrorMessage(constraint);\n    },\n\n    _buildUI: function _buildUI() {\n      // UI could be already built or disabled\n      if (this._ui || false === this.options.uiEnabled) return;\n\n      var _ui = {};\n\n      // Give field its Parsley id in DOM\n      this.element.setAttribute(this.options.namespace + 'id', this.__id__);\n\n      /** Generate important UI elements and store them in this **/\n      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n      _ui.$errorClassHandler = this._manageClassHandler();\n\n      // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n      _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\n      _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n      // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n      _ui.lastValidationResult = [];\n      _ui.validationInformationVisible = false;\n\n      // Store it in this for later\n      this._ui = _ui;\n    },\n\n    // Determine which element will have `parsley-error` and `parsley-success` classes\n    _manageClassHandler: function _manageClassHandler() {\n      // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n      if ('string' === typeof this.options.classHandler) {\n        if ($(this.options.classHandler).length === 0) ParsleyUtils.warn('No elements found that match the selector `' + this.options.classHandler + '` set in options.classHandler or data-parsley-class-handler');\n\n        //return element or empty set\n        return $(this.options.classHandler);\n      }\n\n      // Class handled could also be determined by function given in Parsley options\n      if ('function' === typeof this.options.classHandler) var $handler = this.options.classHandler.call(this, this);\n\n      // If this function returned a valid existing DOM element, go for it\n      if ('undefined' !== typeof $handler && $handler.length) return $handler;\n\n      return this._inputHolder();\n    },\n\n    _inputHolder: function _inputHolder() {\n      // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\n      if (!this.options.multiple || this.element.nodeName === 'SELECT') return this.$element;\n\n      // But if multiple element (radio, checkbox), that would be their parent\n      return this.$element.parent();\n    },\n\n    _insertErrorWrapper: function _insertErrorWrapper() {\n      var $errorsContainer;\n\n      // Nothing to do if already inserted\n      if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();\n\n      if ('string' === typeof this.options.errorsContainer) {\n        if ($(this.options.errorsContainer).length) return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);else Utils.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\n      } else if ('function' === typeof this.options.errorsContainer) $errorsContainer = this.options.errorsContainer.call(this, this);\n\n      if ('undefined' !== typeof $errorsContainer && $errorsContainer.length) return $errorsContainer.append(this._ui.$errorsWrapper);\n\n      return this._inputHolder().after(this._ui.$errorsWrapper);\n    },\n\n    _actualizeTriggers: function _actualizeTriggers() {\n      var _this3 = this;\n\n      var $toBind = this._findRelated();\n      var trigger;\n\n      // Remove Parsley events already bound on this field\n      $toBind.off('.Parsley');\n      if (this._failedOnce) $toBind.on(Utils.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), function () {\n        _this3._validateIfNeeded();\n      });else if (trigger = Utils.namespaceEvents(this.options.trigger, 'Parsley')) {\n        $toBind.on(trigger, function (event) {\n          _this3._validateIfNeeded(event);\n        });\n      }\n    },\n\n    _validateIfNeeded: function _validateIfNeeded(event) {\n      var _this4 = this;\n\n      // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\n      // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n      if (event && /key|input/.test(event.type)) if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold) return;\n\n      if (this.options.debounce) {\n        window.clearTimeout(this._debounced);\n        this._debounced = window.setTimeout(function () {\n          return _this4.validate();\n        }, this.options.debounce);\n      } else this.validate();\n    },\n\n    _resetUI: function _resetUI() {\n      // Reset all event listeners\n      this._failedOnce = false;\n      this._actualizeTriggers();\n\n      // Nothing to do if UI never initialized for this field\n      if ('undefined' === typeof this._ui) return;\n\n      // Reset all errors' li\n      this._ui.$errorsWrapper.removeClass('filled').children().remove();\n\n      // Reset validation class\n      this._resetClass();\n\n      // Reset validation flags and last validation result\n      this._ui.lastValidationResult = [];\n      this._ui.validationInformationVisible = false;\n    },\n\n    _destroyUI: function _destroyUI() {\n      this._resetUI();\n\n      if ('undefined' !== typeof this._ui) this._ui.$errorsWrapper.remove();\n\n      delete this._ui;\n    },\n\n    _successClass: function _successClass() {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\n    },\n    _errorClass: function _errorClass() {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\n    },\n    _resetClass: function _resetClass() {\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\n    }\n  };\n\n  var Form = function Form(element, domOptions, options) {\n    this.__class__ = 'Form';\n\n    this.element = element;\n    this.$element = $(element);\n    this.domOptions = domOptions;\n    this.options = options;\n    this.parent = window.Parsley;\n\n    this.fields = [];\n    this.validationResult = null;\n  };\n\n  var Form__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  Form.prototype = {\n    onSubmitValidate: function onSubmitValidate(event) {\n      var _this5 = this;\n\n      // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n      if (true === event.parsley) return;\n\n      // If we didn't come here through a submit button, use the first one in the form\n      var submitSource = this._submitSource || this.$element.find(Utils._SubmitSelector)[0];\n      this._submitSource = null;\n      this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\n      if (submitSource && null !== submitSource.getAttribute('formnovalidate')) return;\n\n      window.Parsley._remoteCache = {};\n\n      var promise = this.whenValidate({ event: event });\n\n      if ('resolved' === promise.state() && false !== this._trigger('submit')) {\n        // All good, let event go through. We make this distinction because browsers\n        // differ in their handling of `submit` being called from inside a submit event [#1047]\n      } else {\n          // Rejected or pending: cancel this submit\n          event.stopImmediatePropagation();\n          event.preventDefault();\n          if ('pending' === promise.state()) promise.done(function () {\n            _this5._submit(submitSource);\n          });\n        }\n    },\n\n    onSubmitButton: function onSubmitButton(event) {\n      this._submitSource = event.currentTarget;\n    },\n    // internal\n    // _submit submits the form, this time without going through the validations.\n    // Care must be taken to \"fake\" the actual submit button being clicked.\n    _submit: function _submit(submitSource) {\n      if (false === this._trigger('submit')) return;\n      // Add submit button's data\n      if (submitSource) {\n        var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\n        if (0 === $synthetic.length) $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\n        $synthetic.attr({\n          name: submitSource.getAttribute('name'),\n          value: submitSource.getAttribute('value')\n        });\n      }\n\n      this.$element.trigger(_extends($.Event('submit'), { parsley: true }));\n    },\n\n    // Performs validation on fields while triggering events.\n    // @returns `true` if all validations succeeds, `false`\n    // if a failure is immediately detected, or `null`\n    // if dependant on a promise.\n    // Consider using `whenValidate` instead.\n    validate: function validate(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\n\n        var _arguments = _slice.call(arguments);\n\n        var group = _arguments[0];\n        var force = _arguments[1];\n        var silent = _arguments[2];\n        var event = _arguments[3];\n\n        options = { group: group, force: force, silent: silent, event: event };\n      }\n      return Form__statusMapping[this.whenValidate(options).state()];\n    },\n\n    whenValidate: function whenValidate() {\n      var _Utils$all$done$fail$always,\n          _this6 = this;\n\n      var _ref8 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var group = _ref8.group;\n      var force = _ref8.force;\n      var silent = _ref8.silent;\n      var event = _ref8.event;\n\n      this.submitEvent = event;\n      if (event) {\n        this.submitEvent = _extends({}, event, { preventDefault: function preventDefault() {\n            Utils.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\n            _this6.validationResult = false;\n          } });\n      }\n      this.validationResult = true;\n\n      // fire validate event to eventually modify things before every validation\n      this._trigger('validate');\n\n      // Refresh form DOM options and form's fields that could have changed\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function () {\n        return $.map(_this6.fields, function (field) {\n          return field.whenValidate({ force: force, group: group, silent: silent });\n        });\n      });\n\n      return (_Utils$all$done$fail$always = Utils.all(promises).done(function () {\n        _this6._trigger('success');\n      }).fail(function () {\n        _this6.validationResult = false;\n        if (!silent) _this6.focus();\n        _this6._trigger('error');\n      }).always(function () {\n        _this6._trigger('validated');\n      })).pipe.apply(_Utils$all$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));\n    },\n\n    // Iterate over refreshed fields, and stop on first failure.\n    // Returns `true` if all fields are valid, `false` if a failure is detected\n    // or `null` if the result depends on an unresolved promise.\n    // Prefer using `whenValid` instead.\n    isValid: function isValid(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\n\n        var _arguments2 = _slice.call(arguments);\n\n        var group = _arguments2[0];\n        var force = _arguments2[1];\n\n        options = { group: group, force: force };\n      }\n      return Form__statusMapping[this.whenValid(options).state()];\n    },\n\n    // Iterate over refreshed fields and validate them.\n    // Returns a promise.\n    // A validation that immediately fails will interrupt the validations.\n    whenValid: function whenValid() {\n      var _this7 = this;\n\n      var _ref9 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var group = _ref9.group;\n      var force = _ref9.force;\n\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function () {\n        return $.map(_this7.fields, function (field) {\n          return field.whenValid({ group: group, force: force });\n        });\n      });\n      return Utils.all(promises);\n    },\n\n    // Reset UI\n    reset: function reset() {\n      // Form case: emit a reset event for each field\n      for (var i = 0; i < this.fields.length; i++) this.fields[i].reset();\n\n      this._trigger('reset');\n    },\n\n    // Destroy Parsley instance (+ UI)\n    destroy: function destroy() {\n      // Field case: emit destroy event to clean UI and then destroy stored instance\n      this._destroyUI();\n\n      // Form case: destroy all its fields and then destroy stored instance\n      for (var i = 0; i < this.fields.length; i++) this.fields[i].destroy();\n\n      this.$element.removeData('Parsley');\n      this._trigger('destroy');\n    },\n\n    _refreshFields: function _refreshFields() {\n      return this.actualizeOptions()._bindFields();\n    },\n\n    _bindFields: function _bindFields() {\n      var _this8 = this;\n\n      var oldFields = this.fields;\n\n      this.fields = [];\n      this.fieldsMappedById = {};\n\n      this._withoutReactualizingFormOptions(function () {\n        _this8.$element.find(_this8.options.inputs).not(_this8.options.excluded).each(function (_, element) {\n          var fieldInstance = new window.Parsley.Factory(element, {}, _this8);\n\n          // Only add valid and not excluded `Field` and `FieldMultiple` children\n          if (('Field' === fieldInstance.__class__ || 'FieldMultiple' === fieldInstance.__class__) && true !== fieldInstance.options.excluded) {\n            var uniqueId = fieldInstance.__class__ + '-' + fieldInstance.__id__;\n            if ('undefined' === typeof _this8.fieldsMappedById[uniqueId]) {\n              _this8.fieldsMappedById[uniqueId] = fieldInstance;\n              _this8.fields.push(fieldInstance);\n            }\n          }\n        });\n\n        $.each(Utils.difference(oldFields, _this8.fields), function (_, field) {\n          field.reset();\n        });\n      });\n      return this;\n    },\n\n    // Internal only.\n    // Looping on a form's fields to do validation or similar\n    // will trigger reactualizing options on all of them, which\n    // in turn will reactualize the form's options.\n    // To avoid calling actualizeOptions so many times on the form\n    // for nothing, _withoutReactualizingFormOptions temporarily disables\n    // the method actualizeOptions on this form while `fn` is called.\n    _withoutReactualizingFormOptions: function _withoutReactualizingFormOptions(fn) {\n      var oldActualizeOptions = this.actualizeOptions;\n      this.actualizeOptions = function () {\n        return this;\n      };\n      var result = fn();\n      this.actualizeOptions = oldActualizeOptions;\n      return result;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    // Returns true iff event is not interrupted and default not prevented.\n    _trigger: function _trigger(eventName) {\n      return this.trigger('form:' + eventName);\n    }\n\n  };\n\n  var Constraint = function Constraint(parsleyField, name, requirements, priority, isDomConstraint) {\n    var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n    var validator = new Validator(validatorSpec);\n    priority = priority || parsleyField.options[name + 'Priority'] || validator.priority;\n    isDomConstraint = true === isDomConstraint;\n\n    _extends(this, {\n      validator: validator,\n      name: name,\n      requirements: requirements,\n      priority: priority,\n      isDomConstraint: isDomConstraint\n    });\n    this._parseRequirements(parsleyField.options);\n  };\n\n  var capitalize = function capitalize(str) {\n    var cap = str[0].toUpperCase();\n    return cap + str.slice(1);\n  };\n\n  Constraint.prototype = {\n    validate: function validate(value, instance) {\n      var _validator;\n\n      return (_validator = this.validator).validate.apply(_validator, [value].concat(_toConsumableArray(this.requirementList), [instance]));\n    },\n\n    _parseRequirements: function _parseRequirements(options) {\n      var _this9 = this;\n\n      this.requirementList = this.validator.parseRequirements(this.requirements, function (key) {\n        return options[_this9.name + capitalize(key)];\n      });\n    }\n  };\n\n  var Field = function Field(field, domOptions, options, parsleyFormInstance) {\n    this.__class__ = 'Field';\n\n    this.element = field;\n    this.$element = $(field);\n\n    // Set parent if we have one\n    if ('undefined' !== typeof parsleyFormInstance) {\n      this.parent = parsleyFormInstance;\n    }\n\n    this.options = options;\n    this.domOptions = domOptions;\n\n    // Initialize some properties\n    this.constraints = [];\n    this.constraintsByName = {};\n    this.validationResult = true;\n\n    // Bind constraints\n    this._bindConstraints();\n  };\n\n  var parsley_field__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  Field.prototype = {\n    // # Public API\n    // Validate field and trigger some events for mainly `UI`\n    // @returns `true`, an array of the validators that failed, or\n    // `null` if validation is not finished. Prefer using whenValidate\n    validate: function validate(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\n        options = { options: options };\n      }\n      var promise = this.whenValidate(options);\n      if (!promise) // If excluded with `group` option\n        return true;\n      switch (promise.state()) {\n        case 'pending':\n          return null;\n        case 'resolved':\n          return true;\n        case 'rejected':\n          return this.validationResult;\n      }\n    },\n\n    // Validate field and trigger some events for mainly `UI`\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if field is not in the given `group`.\n    whenValidate: function whenValidate() {\n      var _whenValid$always$done$fail$always,\n          _this10 = this;\n\n      var _ref10 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var force = _ref10.force;\n      var group = _ref10.group;\n      var silent = _ref10.silent;\n\n      // do not validate a field if not the same as given validation group\n      this.refreshConstraints();\n      if (group && !this._isInGroup(group)) return;\n\n      this.value = this.getValue();\n\n      // Field Validate event. `this.value` could be altered for custom needs\n      this._trigger('validate');\n\n      return (_whenValid$always$done$fail$always = this.whenValid({ force: force, value: this.value, _refreshed: true }).always(function () {\n        _this10._reflowUI({ silent: silent });\n      }).done(function () {\n        _this10._trigger('success');\n      }).fail(function () {\n        _this10._trigger('error');\n      }).always(function () {\n        _this10._trigger('validated');\n      })).pipe.apply(_whenValid$always$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));\n    },\n\n    hasConstraints: function hasConstraints() {\n      return 0 !== this.constraints.length;\n    },\n\n    // An empty optional field does not need validation\n    needsValidation: function needsValidation(value) {\n      if ('undefined' === typeof value) value = this.getValue();\n\n      // If a field is empty and not required, it is valid\n      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty) return false;\n\n      return true;\n    },\n\n    _isInGroup: function _isInGroup(group) {\n      if (Array.isArray(this.options.group)) return -1 !== $.inArray(group, this.options.group);\n      return this.options.group === group;\n    },\n\n    // Just validate field. Do not trigger any event.\n    // Returns `true` iff all constraints pass, `false` if there are failures,\n    // or `null` if the result can not be determined yet (depends on a promise)\n    // See also `whenValid`.\n    isValid: function isValid(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\n\n        var _arguments3 = _slice.call(arguments);\n\n        var force = _arguments3[0];\n        var value = _arguments3[1];\n\n        options = { force: force, value: value };\n      }\n      var promise = this.whenValid(options);\n      if (!promise) // Excluded via `group`\n        return true;\n      return parsley_field__statusMapping[promise.state()];\n    },\n\n    // Just validate field. Do not trigger any event.\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if the field is not in the given `group`.\n    // The argument `force` will force validation of empty fields.\n    // If a `value` is given, it will be validated instead of the value of the input.\n    whenValid: function whenValid() {\n      var _this11 = this;\n\n      var _ref11 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref11$force = _ref11.force;\n      var force = _ref11$force === undefined ? false : _ref11$force;\n      var value = _ref11.value;\n      var group = _ref11.group;\n      var _refreshed = _ref11._refreshed;\n\n      // Recompute options and rebind constraints to have latest changes\n      if (!_refreshed) this.refreshConstraints();\n      // do not validate a field if not the same as given validation group\n      if (group && !this._isInGroup(group)) return;\n\n      this.validationResult = true;\n\n      // A field without constraint is valid\n      if (!this.hasConstraints()) return $.when();\n\n      // Value could be passed as argument, needed to add more power to 'field:validate'\n      if ('undefined' === typeof value || null === value) value = this.getValue();\n\n      if (!this.needsValidation(value) && true !== force) return $.when();\n\n      var groupedConstraints = this._getGroupedConstraints();\n      var promises = [];\n      $.each(groupedConstraints, function (_, constraints) {\n        // Process one group of constraints at a time, we validate the constraints\n        // and combine the promises together.\n        var promise = Utils.all($.map(constraints, function (constraint) {\n          return _this11._validateConstraint(value, constraint);\n        }));\n        promises.push(promise);\n        if (promise.state() === 'rejected') return false; // Interrupt processing if a group has already failed\n      });\n      return Utils.all(promises);\n    },\n\n    // @returns a promise\n    _validateConstraint: function _validateConstraint(value, constraint) {\n      var _this12 = this;\n\n      var result = constraint.validate(value, this);\n      // Map false to a failed promise\n      if (false === result) result = $.Deferred().reject();\n      // Make sure we return a promise and that we record failures\n      return Utils.all([result]).fail(function (errorMessage) {\n        if (!(_this12.validationResult instanceof Array)) _this12.validationResult = [];\n        _this12.validationResult.push({\n          assert: constraint,\n          errorMessage: 'string' === typeof errorMessage && errorMessage\n        });\n      });\n    },\n\n    // @returns Parsley field computed value that could be overrided or configured in DOM\n    getValue: function getValue() {\n      var value;\n\n      // Value could be overriden in DOM or with explicit options\n      if ('function' === typeof this.options.value) value = this.options.value(this);else if ('undefined' !== typeof this.options.value) value = this.options.value;else value = this.$element.val();\n\n      // Handle wrong DOM or configurations\n      if ('undefined' === typeof value || null === value) return '';\n\n      return this._handleWhitespace(value);\n    },\n\n    // Reset UI\n    reset: function reset() {\n      this._resetUI();\n      return this._trigger('reset');\n    },\n\n    // Destroy Parsley instance (+ UI)\n    destroy: function destroy() {\n      // Field case: emit destroy event to clean UI and then destroy stored instance\n      this._destroyUI();\n      this.$element.removeData('Parsley');\n      this.$element.removeData('FieldMultiple');\n      this._trigger('destroy');\n    },\n\n    // Actualize options that could have change since previous validation\n    // Re-bind accordingly constraints (could be some new, removed or updated)\n    refreshConstraints: function refreshConstraints() {\n      return this.actualizeOptions()._bindConstraints();\n    },\n\n    /**\r\n    * Add a new constraint to a field\r\n    *\r\n    * @param {String}   name\r\n    * @param {Mixed}    requirements      optional\r\n    * @param {Number}   priority          optional\r\n    * @param {Boolean}  isDomConstraint   optional\r\n    */\n    addConstraint: function addConstraint(name, requirements, priority, isDomConstraint) {\n\n      if (window.Parsley._validatorRegistry.validators[name]) {\n        var constraint = new Constraint(this, name, requirements, priority, isDomConstraint);\n\n        // if constraint already exist, delete it and push new version\n        if ('undefined' !== this.constraintsByName[constraint.name]) this.removeConstraint(constraint.name);\n\n        this.constraints.push(constraint);\n        this.constraintsByName[constraint.name] = constraint;\n      }\n\n      return this;\n    },\n\n    // Remove a constraint\n    removeConstraint: function removeConstraint(name) {\n      for (var i = 0; i < this.constraints.length; i++) if (name === this.constraints[i].name) {\n        this.constraints.splice(i, 1);\n        break;\n      }\n      delete this.constraintsByName[name];\n      return this;\n    },\n\n    // Update a constraint (Remove + re-add)\n    updateConstraint: function updateConstraint(name, parameters, priority) {\n      return this.removeConstraint(name).addConstraint(name, parameters, priority);\n    },\n\n    // # Internals\n\n    // Internal only.\n    // Bind constraints from config + options + DOM\n    _bindConstraints: function _bindConstraints() {\n      var constraints = [];\n      var constraintsByName = {};\n\n      // clean all existing DOM constraints to only keep javascript user constraints\n      for (var i = 0; i < this.constraints.length; i++) if (false === this.constraints[i].isDomConstraint) {\n        constraints.push(this.constraints[i]);\n        constraintsByName[this.constraints[i].name] = this.constraints[i];\n      }\n\n      this.constraints = constraints;\n      this.constraintsByName = constraintsByName;\n\n      // then re-add Parsley DOM-API constraints\n      for (var name in this.options) this.addConstraint(name, this.options[name], undefined, true);\n\n      // finally, bind special HTML5 constraints\n      return this._bindHtml5Constraints();\n    },\n\n    // Internal only.\n    // Bind specific HTML5 constraints to be HTML5 compliant\n    _bindHtml5Constraints: function _bindHtml5Constraints() {\n      // html5 required\n      if (null !== this.element.getAttribute('required')) this.addConstraint('required', true, undefined, true);\n\n      // html5 pattern\n      if (null !== this.element.getAttribute('pattern')) this.addConstraint('pattern', this.element.getAttribute('pattern'), undefined, true);\n\n      // range\n      var min = this.element.getAttribute('min');\n      var max = this.element.getAttribute('max');\n      if (null !== min && null !== max) this.addConstraint('range', [min, max], undefined, true);\n\n      // HTML5 min\n      else if (null !== min) this.addConstraint('min', min, undefined, true);\n\n        // HTML5 max\n        else if (null !== max) this.addConstraint('max', max, undefined, true);\n\n      // length\n      if (null !== this.element.getAttribute('minlength') && null !== this.element.getAttribute('maxlength')) this.addConstraint('length', [this.element.getAttribute('minlength'), this.element.getAttribute('maxlength')], undefined, true);\n\n      // HTML5 minlength\n      else if (null !== this.element.getAttribute('minlength')) this.addConstraint('minlength', this.element.getAttribute('minlength'), undefined, true);\n\n        // HTML5 maxlength\n        else if (null !== this.element.getAttribute('maxlength')) this.addConstraint('maxlength', this.element.getAttribute('maxlength'), undefined, true);\n\n      // html5 types\n      var type = this.element.type;\n\n      // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n      if ('number' === type) {\n        return this.addConstraint('type', ['number', {\n          step: this.element.getAttribute('step') || '1',\n          base: min || this.element.getAttribute('value')\n        }], undefined, true);\n        // Regular other HTML5 supported types\n      } else if (/^(email|url|range|date)$/i.test(type)) {\n          return this.addConstraint('type', type, undefined, true);\n        }\n      return this;\n    },\n\n    // Internal only.\n    // Field is required if have required constraint without `false` value\n    _isRequired: function _isRequired() {\n      if ('undefined' === typeof this.constraintsByName.required) return false;\n\n      return false !== this.constraintsByName.required.requirements;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    _trigger: function _trigger(eventName) {\n      return this.trigger('field:' + eventName);\n    },\n\n    // Internal only\n    // Handles whitespace in a value\n    // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n    // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n    _handleWhitespace: function _handleWhitespace(value) {\n      if (true === this.options.trimValue) Utils.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n      if ('squish' === this.options.whitespace) value = value.replace(/\\s{2,}/g, ' ');\n\n      if ('trim' === this.options.whitespace || 'squish' === this.options.whitespace || true === this.options.trimValue) value = Utils.trimString(value);\n\n      return value;\n    },\n\n    _isDateInput: function _isDateInput() {\n      var c = this.constraintsByName.type;\n      return c && c.requirements === 'date';\n    },\n\n    // Internal only.\n    // Returns the constraints, grouped by descending priority.\n    // The result is thus an array of arrays of constraints.\n    _getGroupedConstraints: function _getGroupedConstraints() {\n      if (false === this.options.priorityEnabled) return [this.constraints];\n\n      var groupedConstraints = [];\n      var index = {};\n\n      // Create array unique of priorities\n      for (var i = 0; i < this.constraints.length; i++) {\n        var p = this.constraints[i].priority;\n        if (!index[p]) groupedConstraints.push(index[p] = []);\n        index[p].push(this.constraints[i]);\n      }\n      // Sort them by priority DESC\n      groupedConstraints.sort(function (a, b) {\n        return b[0].priority - a[0].priority;\n      });\n\n      return groupedConstraints;\n    }\n\n  };\n\n  var parsley_field = Field;\n\n  var Multiple = function Multiple() {\n    this.__class__ = 'FieldMultiple';\n  };\n\n  Multiple.prototype = {\n    // Add new `$element` sibling for multiple field\n    addElement: function addElement($element) {\n      this.$elements.push($element);\n\n      return this;\n    },\n\n    // See `Field.refreshConstraints()`\n    refreshConstraints: function refreshConstraints() {\n      var fieldConstraints;\n\n      this.constraints = [];\n\n      // Select multiple special treatment\n      if (this.element.nodeName === 'SELECT') {\n        this.actualizeOptions()._bindConstraints();\n\n        return this;\n      }\n\n      // Gather all constraints for each input in the multiple group\n      for (var i = 0; i < this.$elements.length; i++) {\n\n        // Check if element have not been dynamically removed since last binding\n        if (!$('html').has(this.$elements[i]).length) {\n          this.$elements.splice(i, 1);\n          continue;\n        }\n\n        fieldConstraints = this.$elements[i].data('FieldMultiple').refreshConstraints().constraints;\n\n        for (var j = 0; j < fieldConstraints.length; j++) this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n      }\n\n      return this;\n    },\n\n    // See `Field.getValue()`\n    getValue: function getValue() {\n      // Value could be overriden in DOM\n      if ('function' === typeof this.options.value) return this.options.value(this);else if ('undefined' !== typeof this.options.value) return this.options.value;\n\n      // Radio input case\n      if (this.element.nodeName === 'INPUT') {\n        if (this.element.type === 'radio') return this._findRelated().filter(':checked').val() || '';\n\n        // checkbox input case\n        if (this.element.type === 'checkbox') {\n          var values = [];\n\n          this._findRelated().filter(':checked').each(function () {\n            values.push($(this).val());\n          });\n\n          return values;\n        }\n      }\n\n      // Select multiple case\n      if (this.element.nodeName === 'SELECT' && null === this.$element.val()) return [];\n\n      // Default case that should never happen\n      return this.$element.val();\n    },\n\n    _init: function _init() {\n      this.$elements = [this.$element];\n\n      return this;\n    }\n  };\n\n  var Factory = function Factory(element, options, parsleyFormInstance) {\n    this.element = element;\n    this.$element = $(element);\n\n    // If the element has already been bound, returns its saved Parsley instance\n    var savedparsleyFormInstance = this.$element.data('Parsley');\n    if (savedparsleyFormInstance) {\n\n      // If the saved instance has been bound without a Form parent and there is one given in this call, add it\n      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n        savedparsleyFormInstance.parent = parsleyFormInstance;\n        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n      }\n\n      if ('object' === typeof options) {\n        _extends(savedparsleyFormInstance.options, options);\n      }\n\n      // return\n      return savedparsleyFormInstance;\n    }\n\n    // Parsley must be instantiated with a DOM element or jQuery $element\n    if (!this.$element.length) throw new Error('You must bind Parsley on an existing element.');\n\n    if ('undefined' !== typeof parsleyFormInstance && 'Form' !== parsleyFormInstance.__class__) throw new Error('Parent instance must be a Form instance');\n\n    this.parent = parsleyFormInstance || window.Parsley;\n\n    // return\n    return this.init(options);\n  };\n\n  Factory.prototype = {\n    init: function init(options) {\n      this.__class__ = 'Parsley';\n      this.__version__ = '2.7.3';\n      this.__id__ = Utils.generateID();\n\n      // Pre-compute options\n      this._resetOptions(options);\n\n      // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n      if (this.element.nodeName === 'FORM' || Utils.checkAttr(this.element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)) return this.bind('parsleyForm');\n\n      // Every other element is bound as a `Field` or `FieldMultiple`\n      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n    },\n\n    isMultiple: function isMultiple() {\n      return this.element.type === 'radio' || this.element.type === 'checkbox' || this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple');\n    },\n\n    // Multiples fields are a real nightmare :(\n    // Maybe some refactoring would be appreciated here...\n    handleMultiple: function handleMultiple() {\n      var _this13 = this;\n\n      var name;\n      var multiple;\n      var parsleyMultipleInstance;\n\n      // Handle multiple name\n      this.options.multiple = this.options.multiple || (name = this.element.getAttribute('name')) || this.element.getAttribute('id');\n\n      // Special select multiple input\n      if (this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple')) {\n        this.options.multiple = this.options.multiple || this.__id__;\n        return this.bind('parsleyFieldMultiple');\n\n        // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n      } else if (!this.options.multiple) {\n          Utils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n          return this;\n        }\n\n      // Remove special chars\n      this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n      // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n      if (name) {\n        $('input[name=\"' + name + '\"]').each(function (i, input) {\n          if (input.type === 'radio' || input.type === 'checkbox') input.setAttribute(_this13.options.namespace + 'multiple', _this13.options.multiple);\n        });\n      }\n\n      // Check here if we don't already have a related multiple instance saved\n      var $previouslyRelated = this._findRelated();\n      for (var i = 0; i < $previouslyRelated.length; i++) {\n        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n        if ('undefined' !== typeof parsleyMultipleInstance) {\n\n          if (!this.$element.data('FieldMultiple')) {\n            parsleyMultipleInstance.addElement(this.$element);\n          }\n\n          break;\n        }\n      }\n\n      // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`\n      // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance\n      this.bind('parsleyField', true);\n\n      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n    },\n\n    // Return proper `Form`, `Field` or `FieldMultiple`\n    bind: function bind(type, doNotStore) {\n      var parsleyInstance;\n\n      switch (type) {\n        case 'parsleyForm':\n          parsleyInstance = $.extend(new Form(this.element, this.domOptions, this.options), new Base(), window.ParsleyExtend)._bindFields();\n          break;\n        case 'parsleyField':\n          parsleyInstance = $.extend(new parsley_field(this.element, this.domOptions, this.options, this.parent), new Base(), window.ParsleyExtend);\n          break;\n        case 'parsleyFieldMultiple':\n          parsleyInstance = $.extend(new parsley_field(this.element, this.domOptions, this.options, this.parent), new Multiple(), new Base(), window.ParsleyExtend)._init();\n          break;\n        default:\n          throw new Error(type + 'is not a supported Parsley type');\n      }\n\n      if (this.options.multiple) Utils.setAttr(this.element, this.options.namespace, 'multiple', this.options.multiple);\n\n      if ('undefined' !== typeof doNotStore) {\n        this.$element.data('FieldMultiple', parsleyInstance);\n\n        return parsleyInstance;\n      }\n\n      // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n      this.$element.data('Parsley', parsleyInstance);\n\n      // Tell the world we have a new Form or Field instance!\n      parsleyInstance._actualizeTriggers();\n      parsleyInstance._trigger('init');\n\n      return parsleyInstance;\n    }\n  };\n\n  var vernums = $.fn.jquery.split('.');\n  if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\n    throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\n  }\n  if (!vernums.forEach) {\n    Utils.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\n  }\n  // Inherit `on`, `off` & `trigger` to Parsley:\n  var Parsley = _extends(new Base(), {\n    element: document,\n    $element: $(document),\n    actualizeOptions: null,\n    _resetOptions: null,\n    Factory: Factory,\n    version: '2.7.3'\n  });\n\n  // Supplement Field and Form with Base\n  // This way, the constructors will have access to those methods\n  _extends(parsley_field.prototype, UI.Field, Base.prototype);\n  _extends(Form.prototype, UI.Form, Base.prototype);\n  // Inherit actualizeOptions and _resetOptions:\n  _extends(Factory.prototype, Base.prototype);\n\n  // ### jQuery API\n  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n  $.fn.parsley = $.fn.psly = function (options) {\n    if (this.length > 1) {\n      var instances = [];\n\n      this.each(function () {\n        instances.push($(this).parsley(options));\n      });\n\n      return instances;\n    }\n\n    // Return undefined if applied to non existing DOM element\n    if (!$(this).length) {\n      Utils.warn('You must bind Parsley on an existing element.');\n\n      return;\n    }\n\n    return new Factory(this[0], options);\n  };\n\n  // ### Field and Form extension\n  // Ensure the extension is now defined if it wasn't previously\n  if ('undefined' === typeof window.ParsleyExtend) window.ParsleyExtend = {};\n\n  // ### Parsley config\n  // Inherit from ParsleyDefault, and copy over any existing values\n  Parsley.options = _extends(Utils.objectCreate(Defaults), window.ParsleyConfig);\n  window.ParsleyConfig = Parsley.options; // Old way of accessing global options\n\n  // ### Globals\n  window.Parsley = window.psly = Parsley;\n  Parsley.Utils = Utils;\n  window.ParsleyUtils = {};\n  $.each(Utils, function (key, value) {\n    if ('function' === typeof value) {\n      window.ParsleyUtils[key] = function () {\n        Utils.warnOnce('Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.');\n        return Utils[key].apply(Utils, arguments);\n      };\n    }\n  });\n\n  // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\n  var registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\n  window.ParsleyValidator = {};\n  $.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n    window.Parsley[method] = function () {\n      return registry[method].apply(registry, arguments);\n    };\n    window.ParsleyValidator[method] = function () {\n      var _window$Parsley;\n\n      Utils.warnOnce('Accessing the method \\'' + method + '\\' through Validator is deprecated. Simply call \\'window.Parsley.' + method + '(...)\\'');\n      return (_window$Parsley = window.Parsley)[method].apply(_window$Parsley, arguments);\n    };\n  });\n\n  // ### UI\n  // Deprecated global object\n  window.Parsley.UI = UI;\n  window.ParsleyUI = {\n    removeError: function removeError(instance, name, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      Utils.warnOnce('Accessing UI is deprecated. Call \\'removeError\\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');\n      return instance.removeError(name, { updateClass: updateClass });\n    },\n    getErrorsMessages: function getErrorsMessages(instance) {\n      Utils.warnOnce('Accessing UI is deprecated. Call \\'getErrorsMessages\\' on the instance directly.');\n      return instance.getErrorsMessages();\n    }\n  };\n  $.each('addError updateError'.split(' '), function (i, method) {\n    window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      Utils.warnOnce('Accessing UI is deprecated. Call \\'' + method + '\\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');\n      return instance[method](name, { message: message, assert: assert, updateClass: updateClass });\n    };\n  });\n\n  // ### PARSLEY auto-binding\n  // Prevent it by setting `ParsleyConfig.autoBind` to `false`\n  if (false !== window.ParsleyConfig.autoBind) {\n    $(function () {\n      // Works only on `data-parsley-validate`.\n      if ($('[data-parsley-validate]').length) $('[data-parsley-validate]').parsley();\n    });\n  }\n\n  var o = $({});\n  var deprecated = function deprecated() {\n    Utils.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n  };\n\n  // Returns an event handler that calls `fn` with the arguments it expects\n  function adapt(fn, context) {\n    // Store to allow unbinding\n    if (!fn.parsleyAdaptedCallback) {\n      fn.parsleyAdaptedCallback = function () {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args.unshift(this);\n        fn.apply(context || o, args);\n      };\n    }\n    return fn.parsleyAdaptedCallback;\n  }\n\n  var eventPrefix = 'parsley:';\n  // Converts 'parsley:form:validate' into 'form:validate'\n  function eventName(name) {\n    if (name.lastIndexOf(eventPrefix, 0) === 0) return name.substr(eventPrefix.length);\n    return name;\n  }\n\n  // $.listen is deprecated. Use Parsley.on instead.\n  $.listen = function (name, callback) {\n    var context;\n    deprecated();\n    if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n      context = arguments[1];\n      callback = arguments[2];\n    }\n\n    if ('function' !== typeof callback) throw new Error('Wrong parameters');\n\n    window.Parsley.on(eventName(name), adapt(callback, context));\n  };\n\n  $.listenTo = function (instance, name, fn) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');\n\n    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong parameters');\n\n    instance.on(eventName(name), adapt(fn));\n  };\n\n  $.unsubscribe = function (name, fn) {\n    deprecated();\n    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong arguments');\n    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n  };\n\n  $.unsubscribeTo = function (instance, name) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');\n    instance.off(eventName(name));\n  };\n\n  $.unsubscribeAll = function (name) {\n    deprecated();\n    window.Parsley.off(eventName(name));\n    $('form,input,textarea,select').each(function () {\n      var instance = $(this).data('Parsley');\n      if (instance) {\n        instance.off(eventName(name));\n      }\n    });\n  };\n\n  // $.emit is deprecated. Use jQuery events instead.\n  $.emit = function (name, instance) {\n    var _instance;\n\n    deprecated();\n    var instanceGiven = instance instanceof parsley_field || instance instanceof Form;\n    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n    args.unshift(eventName(name));\n    if (!instanceGiven) {\n      instance = window.Parsley;\n    }\n    (_instance = instance).trigger.apply(_instance, _toConsumableArray(args));\n  };\n\n  var pubsub = {};\n\n  $.extend(true, Parsley, {\n    asyncValidators: {\n      'default': {\n        fn: function fn(xhr) {\n          // By default, only status 2xx are deemed successful.\n          // Note: we use status instead of state() because responses with status 200\n          // but invalid messages (e.g. an empty body for content type set to JSON) will\n          // result in state() === 'rejected'.\n          return xhr.status >= 200 && xhr.status < 300;\n        },\n        url: false\n      },\n      reverse: {\n        fn: function fn(xhr) {\n          // If reverse option is set, a failing ajax request is considered successful\n          return xhr.status < 200 || xhr.status >= 300;\n        },\n        url: false\n      }\n    },\n\n    addAsyncValidator: function addAsyncValidator(name, fn, url, options) {\n      Parsley.asyncValidators[name] = {\n        fn: fn,\n        url: url || false,\n        options: options || {}\n      };\n\n      return this;\n    }\n\n  });\n\n  Parsley.addValidator('remote', {\n    requirementType: {\n      '': 'string',\n      'validator': 'string',\n      'reverse': 'boolean',\n      'options': 'object'\n    },\n\n    validateString: function validateString(value, url, options, instance) {\n      var data = {};\n      var ajaxOptions;\n      var csr;\n      var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\n\n      if ('undefined' === typeof Parsley.asyncValidators[validator]) throw new Error('Calling an undefined async validator: `' + validator + '`');\n\n      url = Parsley.asyncValidators[validator].url || url;\n\n      // Fill current value\n      if (url.indexOf('{value}') > -1) {\n        url = url.replace('{value}', encodeURIComponent(value));\n      } else {\n        data[instance.element.getAttribute('name') || instance.element.getAttribute('id')] = value;\n      }\n\n      // Merge options passed in from the function with the ones in the attribute\n      var remoteOptions = $.extend(true, options.options || {}, Parsley.asyncValidators[validator].options);\n\n      // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\n      ajaxOptions = $.extend(true, {}, {\n        url: url,\n        data: data,\n        type: 'GET'\n      }, remoteOptions);\n\n      // Generate store key based on ajax options\n      instance.trigger('field:ajaxoptions', instance, ajaxOptions);\n\n      csr = $.param(ajaxOptions);\n\n      // Initialise querry cache\n      if ('undefined' === typeof Parsley._remoteCache) Parsley._remoteCache = {};\n\n      // Try to retrieve stored xhr\n      var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\n\n      var handleXhr = function handleXhr() {\n        var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\n        if (!result) // Map falsy results to rejected promise\n          result = $.Deferred().reject();\n        return $.when(result);\n      };\n\n      return xhr.then(handleXhr, handleXhr);\n    },\n\n    priority: -1\n  });\n\n  Parsley.on('form:submit', function () {\n    Parsley._remoteCache = {};\n  });\n\n  Base.prototype.addAsyncValidator = function () {\n    Utils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\n    return Parsley.addAsyncValidator.apply(Parsley, arguments);\n  };\n\n  // This is included with the Parsley library itself,\n  // thus there is no use in adding it to your project.\n  Parsley.addMessages('en', {\n    defaultMessage: \"This value seems to be invalid.\",\n    type: {\n      email: \"This value should be a valid email.\",\n      url: \"This value should be a valid url.\",\n      number: \"This value should be a valid number.\",\n      integer: \"This value should be a valid integer.\",\n      digits: \"This value should be digits.\",\n      alphanum: \"This value should be alphanumeric.\"\n    },\n    notblank: \"This value should not be blank.\",\n    required: \"This value is required.\",\n    pattern: \"This value seems to be invalid.\",\n    min: \"This value should be greater than or equal to %s.\",\n    max: \"This value should be lower than or equal to %s.\",\n    range: \"This value should be between %s and %s.\",\n    minlength: \"This value is too short. It should have %s characters or more.\",\n    maxlength: \"This value is too long. It should have %s characters or fewer.\",\n    length: \"This value length is invalid. It should be between %s and %s characters long.\",\n    mincheck: \"You must select at least %s choices.\",\n    maxcheck: \"You must select %s choices or fewer.\",\n    check: \"You must select between %s and %s choices.\",\n    equalto: \"This value should be the same.\"\n  });\n\n  Parsley.setLocale('en');\n\n  /**\r\n   * inputevent - Alleviate browser bugs for input events\r\n   * https://github.com/marcandre/inputevent\r\n   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)\r\n   * @author Marc-Andre Lafortune <github@marc-andre.ca>\r\n   * @license MIT\r\n   */\n\n  function InputEvent() {\n    var _this14 = this;\n\n    var globals = window || global;\n\n    // Slightly odd way construct our object. This way methods are force bound.\n    // Used to test for duplicate library.\n    _extends(this, {\n\n      // For browsers that do not support isTrusted, assumes event is native.\n      isNativeEvent: function isNativeEvent(evt) {\n        return evt.originalEvent && evt.originalEvent.isTrusted !== false;\n      },\n\n      fakeInputEvent: function fakeInputEvent(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          $(evt.target).trigger('input');\n        }\n      },\n\n      misbehaves: function misbehaves(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          _this14.behavesOk(evt);\n          $(document).on('change.inputevent', evt.data.selector, _this14.fakeInputEvent);\n          _this14.fakeInputEvent(evt);\n        }\n      },\n\n      behavesOk: function behavesOk(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          $(document) // Simply unbinds the testing handler\n          .off('input.inputevent', evt.data.selector, _this14.behavesOk).off('change.inputevent', evt.data.selector, _this14.misbehaves);\n        }\n      },\n\n      // Bind the testing handlers\n      install: function install() {\n        if (globals.inputEventPatched) {\n          return;\n        }\n        globals.inputEventPatched = '0.0.3';\n        var _arr = ['select', 'input[type=\"checkbox\"]', 'input[type=\"radio\"]', 'input[type=\"file\"]'];\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var selector = _arr[_i];\n          $(document).on('input.inputevent', selector, { selector: selector }, _this14.behavesOk).on('change.inputevent', selector, { selector: selector }, _this14.misbehaves);\n        }\n      },\n\n      uninstall: function uninstall() {\n        delete globals.inputEventPatched;\n        $(document).off('.inputevent');\n      }\n\n    });\n  };\n\n  var inputevent = new InputEvent();\n\n  inputevent.install();\n\n  var parsley = Parsley;\n\n  return parsley;\n});\n//# sourceMappingURL=parsley.js.map\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery')) :\n  typeof define === 'function' && define.amd ? define(['jquery'], factory) :\n  global.parsley = factory(global.$)\n}(this, function ($) { 'use strict';\n\n  var globalID = 1;\r\n  var pastWarnings = {};\r\n\r\n  var Utils = {\r\n    // Parsley DOM-API\r\n    // returns object from dom attributes and values\r\n    attr: function (element, namespace, obj) {\r\n      var i;\r\n      var attribute;\r\n      var attributes;\r\n      var regex = new RegExp('^' + namespace, 'i');\r\n\r\n      if ('undefined' === typeof obj)\r\n        obj = {};\r\n      else {\r\n        // Clear all own properties. This won't affect prototype's values\r\n        for (i in obj) {\r\n          if (obj.hasOwnProperty(i))\r\n            delete obj[i];\r\n        }\r\n      }\r\n\r\n      if (!element)\r\n        return obj;\r\n\r\n      attributes = element.attributes;\r\n      for (i = attributes.length; i--; ) {\r\n        attribute = attributes[i];\r\n\r\n        if (attribute && attribute.specified && regex.test(attribute.name)) {\r\n          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\r\n        }\r\n      }\r\n\r\n      return obj;\r\n    },\r\n\r\n    checkAttr: function (element, namespace, checkAttr) {\r\n      return element.hasAttribute(namespace + checkAttr);\r\n    },\r\n\r\n    setAttr: function (element, namespace, attr, value) {\r\n      element.setAttribute(this.dasherize(namespace + attr), String(value));\r\n    },\r\n\r\n    generateID: function () {\r\n      return '' + globalID++;\r\n    },\r\n\r\n    /** Third party functions **/\r\n    // Zepto deserialize function\r\n    deserializeValue: function (value) {\r\n      var num;\r\n\r\n      try {\r\n        return value ?\r\n          value == \"true\" ||\r\n          (value == \"false\" ? false :\r\n          value == \"null\" ? null :\r\n          !isNaN(num = Number(value)) ? num :\r\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\r\n          value)\r\n          : value;\r\n      } catch (e) { return value; }\r\n    },\r\n\r\n    // Zepto camelize function\r\n    camelize: function (str) {\r\n      return str.replace(/-+(.)?/g, function (match, chr) {\r\n        return chr ? chr.toUpperCase() : '';\r\n      });\r\n    },\r\n\r\n    // Zepto dasherize function\r\n    dasherize: function (str) {\r\n      return str.replace(/::/g, '/')\r\n        .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\r\n        .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\r\n        .replace(/_/g, '-')\r\n        .toLowerCase();\r\n    },\r\n\r\n    warn: function () {\r\n      if (window.console && 'function' === typeof window.console.warn)\r\n        window.console.warn(...arguments);\r\n    },\r\n\r\n    warnOnce: function(msg) {\r\n      if (!pastWarnings[msg]) {\r\n        pastWarnings[msg] = true;\r\n        this.warn(...arguments);\r\n      }\r\n    },\r\n\r\n    _resetWarnings: function () {\r\n      pastWarnings = {};\r\n    },\r\n\r\n    trimString: function(string) {\r\n      return string.replace(/^\\s+|\\s+$/g, '');\r\n    },\r\n\r\n    parse: {\r\n      date: function(string) {\r\n        let parsed = string.match(/^(\\d{4,})-(\\d\\d)-(\\d\\d)$/);\r\n        if (!parsed)\r\n          return null;\r\n        let [_, year, month, day] = parsed.map(x => parseInt(x, 10));\r\n        let date = new Date(year, month - 1, day);\r\n        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day)\r\n          return null;\r\n        return date;\r\n      },\r\n      string: function(string) {\r\n        return string;\r\n      },\r\n      integer: function(string) {\r\n        if (isNaN(string))\r\n          return null;\r\n        return parseInt(string, 10);\r\n      },\r\n      number: function(string) {\r\n        if (isNaN(string))\r\n          throw null;\r\n        return parseFloat(string);\r\n      },\r\n      'boolean': function _boolean(string) {\r\n        return !(/^\\s*false\\s*$/i.test(string));\r\n      },\r\n      object: function(string) {\r\n        return Utils.deserializeValue(string);\r\n      },\r\n      regexp: function(regexp) {\r\n        var flags = '';\r\n\r\n        // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\r\n        if (/^\\/.*\\/(?:[gimy]*)$/.test(regexp)) {\r\n          // Replace the regexp literal string with the first match group: ([gimy]*)\r\n          // If no flag is present, this will be a blank string\r\n          flags = regexp.replace(/.*\\/([gimy]*)$/, '$1');\r\n          // Again, replace the regexp literal string with the first match group:\r\n          // everything excluding the opening and closing slashes and the flags\r\n          regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\r\n        } else {\r\n          // Anchor regexp:\r\n          regexp = '^' + regexp + '$';\r\n        }\r\n        return new RegExp(regexp, flags);\r\n      }\r\n    },\r\n\r\n    parseRequirement: function(requirementType, string) {\r\n      var converter = this.parse[requirementType || 'string'];\r\n      if (!converter)\r\n        throw 'Unknown requirement specification: \"' + requirementType + '\"';\r\n      let converted = converter(string);\r\n      if (converted === null)\r\n        throw `Requirement is not a ${requirementType}: \"${string}\"`;\r\n      return converted;\r\n    },\r\n\r\n    namespaceEvents: function(events, namespace) {\r\n      events = this.trimString(events || '').split(/\\s+/);\r\n      if (!events[0])\r\n        return '';\r\n      return $.map(events, evt => `${evt}.${namespace}`).join(' ');\r\n    },\r\n\r\n    difference: function(array, remove) {\r\n      // This is O(N^2), should be optimized\r\n      let result = [];\r\n      $.each(array, (_, elem) => {\r\n        if (remove.indexOf(elem) == -1)\r\n          result.push(elem);\r\n      });\r\n      return result;\r\n    },\r\n\r\n    // Alter-ego to native Promise.all, but for jQuery\r\n    all: function(promises) {\r\n      // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\r\n      return $.when(...promises, 42, 42);\r\n    },\r\n\r\n    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\r\n    objectCreate: Object.create || (function () {\r\n      var Object = function () {};\r\n      return function (prototype) {\r\n        if (arguments.length > 1) {\r\n          throw Error('Second argument not supported');\r\n        }\r\n        if (typeof prototype != 'object') {\r\n          throw TypeError('Argument must be an object');\r\n        }\r\n        Object.prototype = prototype;\r\n        var result = new Object();\r\n        Object.prototype = null;\r\n        return result;\r\n      };\r\n    })(),\r\n\r\n    _SubmitSelector: 'input[type=\"submit\"], button:submit'\r\n  };\n\n  // All these options could be overriden and specified directly in DOM using\r\n  // `data-parsley-` default DOM-API\r\n  // eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\r\n  // eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\r\n\r\n  var Defaults = {\r\n    // ### General\r\n\r\n    // Default data-namespace for DOM API\r\n    namespace: 'data-parsley-',\r\n\r\n    // Supported inputs by default\r\n    inputs: 'input, textarea, select',\r\n\r\n    // Excluded inputs by default\r\n    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\r\n\r\n    // Stop validating field on highest priority failing constraint\r\n    priorityEnabled: true,\r\n\r\n    // ### Field only\r\n\r\n    // identifier used to group together inputs (e.g. radio buttons...)\r\n    multiple: null,\r\n\r\n    // identifier (or array of identifiers) used to validate only a select group of inputs\r\n    group: null,\r\n\r\n    // ### UI\r\n    // Enable\\Disable error messages\r\n    uiEnabled: true,\r\n\r\n    // Key events threshold before validation\r\n    validationThreshold: 3,\r\n\r\n    // Focused field on form validation error. 'first'|'last'|'none'\r\n    focus: 'first',\r\n\r\n    // event(s) that will trigger validation before first failure. eg: `input`...\r\n    trigger: false,\r\n\r\n    // event(s) that will trigger validation after first failure.\r\n    triggerAfterFailure: 'input',\r\n\r\n    // Class that would be added on every failing validation Parsley field\r\n    errorClass: 'parsley-error',\r\n\r\n    // Same for success validation\r\n    successClass: 'parsley-success',\r\n\r\n    // Return the `$element` that will receive these above success or error classes\r\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\r\n    classHandler: function (Field) {},\r\n\r\n    // Return the `$element` where errors will be appended\r\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\r\n    errorsContainer: function (Field) {},\r\n\r\n    // ul elem that would receive errors' list\r\n    errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\r\n\r\n    // li elem that would receive error message\r\n    errorTemplate: '<li></li>'\r\n  };\n\n  var Base = function () {\r\n    this.__id__ = Utils.generateID();\r\n  };\r\n\r\n  Base.prototype = {\r\n    asyncSupport: true, // Deprecated\r\n\r\n    _pipeAccordingToValidationResult: function () {\r\n      var pipe = () => {\r\n        var r = $.Deferred();\r\n        if (true !== this.validationResult)\r\n          r.reject();\r\n        return r.resolve().promise();\r\n      };\r\n      return [pipe, pipe];\r\n    },\r\n\r\n    actualizeOptions: function () {\r\n      Utils.attr(this.element, this.options.namespace, this.domOptions);\r\n      if (this.parent && this.parent.actualizeOptions)\r\n        this.parent.actualizeOptions();\r\n      return this;\r\n    },\r\n\r\n    _resetOptions: function (initOptions) {\r\n      this.domOptions = Utils.objectCreate(this.parent.options);\r\n      this.options = Utils.objectCreate(this.domOptions);\r\n      // Shallow copy of ownProperties of initOptions:\r\n      for (var i in initOptions) {\r\n        if (initOptions.hasOwnProperty(i))\r\n          this.options[i] = initOptions[i];\r\n      }\r\n      this.actualizeOptions();\r\n    },\r\n\r\n    _listeners: null,\r\n\r\n    // Register a callback for the given event name\r\n    // Callback is called with context as the first argument and the `this`\r\n    // The context is the current parsley instance, or window.Parsley if global\r\n    // A return value of `false` will interrupt the calls\r\n    on: function (name, fn) {\r\n      this._listeners = this._listeners || {};\r\n      var queue = this._listeners[name] = this._listeners[name] || [];\r\n      queue.push(fn);\r\n\r\n      return this;\r\n    },\r\n\r\n    // Deprecated. Use `on` instead\r\n    subscribe: function(name, fn) {\r\n      $.listenTo(this, name.toLowerCase(), fn);\r\n    },\r\n\r\n    // Unregister a callback (or all if none is given) for the given event name\r\n    off: function (name, fn) {\r\n      var queue = this._listeners && this._listeners[name];\r\n      if (queue) {\r\n        if (!fn) {\r\n          delete this._listeners[name];\r\n        } else {\r\n          for (var i = queue.length; i--; )\r\n            if (queue[i] === fn)\r\n              queue.splice(i, 1);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Deprecated. Use `off`\r\n    unsubscribe: function(name, fn) {\r\n      $.unsubscribeTo(this, name.toLowerCase());\r\n    },\r\n\r\n    // Trigger an event of the given name\r\n    // A return value of `false` interrupts the callback chain\r\n    // Returns false if execution was interrupted\r\n    trigger: function (name, target, extraArg) {\r\n      target = target || this;\r\n      var queue = this._listeners && this._listeners[name];\r\n      var result;\r\n      var parentResult;\r\n      if (queue) {\r\n        for (var i = queue.length; i--; ) {\r\n          result = queue[i].call(target, target, extraArg);\r\n          if (result === false) return result;\r\n        }\r\n      }\r\n      if (this.parent) {\r\n        return this.parent.trigger(name, target, extraArg);\r\n      }\r\n      return true;\r\n    },\r\n\r\n    asyncIsValid: function (group, force) {\r\n      Utils.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\r\n      return this.whenValid({group, force});\r\n    },\r\n\r\n    _findRelated: function () {\r\n      return this.options.multiple ?\r\n        $(this.parent.element.querySelectorAll(`[${this.options.namespace}multiple=\"${this.options.multiple}\"]`))\r\n      : this.$element;\r\n    }\r\n  };\n\n  var convertArrayRequirement = function(string, length) {\r\n    var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\r\n    if (!m)\r\n      throw 'Requirement is not an array: \"' + string + '\"';\r\n    var values = m[1].split(',').map(Utils.trimString);\r\n    if (values.length !== length)\r\n      throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\r\n    return values;\r\n  };\r\n\r\n  var convertExtraOptionRequirement = function(requirementSpec, string, extraOptionReader) {\r\n    var main = null;\r\n    var extra = {};\r\n    for (var key in requirementSpec) {\r\n      if (key) {\r\n        var value = extraOptionReader(key);\r\n        if ('string' === typeof value)\r\n          value = Utils.parseRequirement(requirementSpec[key], value);\r\n        extra[key] = value;\r\n      } else {\r\n        main = Utils.parseRequirement(requirementSpec[key], string);\r\n      }\r\n    }\r\n    return [main, extra];\r\n  };\r\n\r\n  // A Validator needs to implement the methods `validate` and `parseRequirements`\r\n\r\n  var Validator = function(spec) {\r\n    $.extend(true, this, spec);\r\n  };\r\n\r\n  Validator.prototype = {\r\n    // Returns `true` iff the given `value` is valid according the given requirements.\r\n    validate: function(value, requirementFirstArg) {\r\n      if (this.fn) { // Legacy style validator\r\n\r\n        if (arguments.length > 3)  // If more args then value, requirement, instance...\r\n          requirementFirstArg = [].slice.call(arguments, 1, -1);  // Skip first arg (value) and last (instance), combining the rest\r\n        return this.fn(value, requirementFirstArg);\r\n      }\r\n\r\n      if (Array.isArray(value)) {\r\n        if (!this.validateMultiple)\r\n          throw 'Validator `' + this.name + '` does not handle multiple values';\r\n        return this.validateMultiple(...arguments);\r\n      } else {\r\n        let instance = arguments[arguments.length - 1];\r\n        if (this.validateDate && instance._isDateInput()) {\r\n          arguments[0] = Utils.parse.date(arguments[0]);\r\n          if (arguments[0] === null)\r\n            return false;\r\n          return this.validateDate(...arguments);\r\n        }\r\n        if (this.validateNumber) {\r\n          if (isNaN(value))\r\n            return false;\r\n          arguments[0] = parseFloat(arguments[0]);\r\n          return this.validateNumber(...arguments);\r\n        }\r\n        if (this.validateString) {\r\n          return this.validateString(...arguments);\r\n        }\r\n        throw 'Validator `' + this.name + '` only handles multiple values';\r\n      }\r\n    },\r\n\r\n    // Parses `requirements` into an array of arguments,\r\n    // according to `this.requirementType`\r\n    parseRequirements: function(requirements, extraOptionReader) {\r\n      if ('string' !== typeof requirements) {\r\n        // Assume requirement already parsed\r\n        // but make sure we return an array\r\n        return Array.isArray(requirements) ? requirements : [requirements];\r\n      }\r\n      var type = this.requirementType;\r\n      if (Array.isArray(type)) {\r\n        var values = convertArrayRequirement(requirements, type.length);\r\n        for (var i = 0; i < values.length; i++)\r\n          values[i] = Utils.parseRequirement(type[i], values[i]);\r\n        return values;\r\n      } else if ($.isPlainObject(type)) {\r\n        return convertExtraOptionRequirement(type, requirements, extraOptionReader);\r\n      } else {\r\n        return [Utils.parseRequirement(type, requirements)];\r\n      }\r\n    },\r\n    // Defaults:\r\n    requirementType: 'string',\r\n\r\n    priority: 2\r\n\r\n  };\n\n  var ValidatorRegistry = function (validators, catalog) {\r\n    this.__class__ = 'ValidatorRegistry';\r\n\r\n    // Default Parsley locale is en\r\n    this.locale = 'en';\r\n\r\n    this.init(validators || {}, catalog || {});\r\n  };\r\n\r\n  var typeTesters =  {\r\n    email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\r\n\r\n    // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\r\n    number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\r\n\r\n    integer: /^-?\\d+$/,\r\n\r\n    digits: /^\\d+$/,\r\n\r\n    alphanum: /^\\w+$/i,\r\n\r\n    date: {\r\n      test: value => Utils.parse.date(value) !== null\r\n    },\r\n\r\n    url: new RegExp(\r\n        \"^\" +\r\n          // protocol identifier\r\n          \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\r\n          // user:pass authentication\r\n          \"(?:\\\\S+(?::\\\\S*)?@)?\" +\r\n          \"(?:\" +\r\n            // IP address exclusion\r\n            // private & local networks\r\n            // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\r\n            // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\r\n            // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\r\n            // IP address dotted notation octets\r\n            // excludes loopback network 0.0.0.0\r\n            // excludes reserved space >= 224.0.0.0\r\n            // excludes network & broacast addresses\r\n            // (first & last IP address of each class)\r\n            \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\r\n            \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\r\n            \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\r\n          \"|\" +\r\n            // host name\r\n            \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\r\n            // domain name\r\n            \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\r\n            // TLD identifier\r\n            \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\r\n          \")\" +\r\n          // port number\r\n          \"(?::\\\\d{2,5})?\" +\r\n          // resource path\r\n          \"(?:/\\\\S*)?\" +\r\n        \"$\", 'i'\r\n      )\r\n  };\r\n  typeTesters.range = typeTesters.number;\r\n\r\n  // See http://stackoverflow.com/a/10454560/8279\r\n  var decimalPlaces = num => {\r\n    var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\r\n    if (!match) { return 0; }\r\n    return Math.max(\r\n         0,\r\n         // Number of digits right of decimal point.\r\n         (match[1] ? match[1].length : 0) -\r\n         // Adjust for scientific notation.\r\n         (match[2] ? +match[2] : 0));\r\n  };\r\n\r\n  // parseArguments('number', ['1', '2']) => [1, 2]\r\n  let ValidatorRegistry__parseArguments = (type, args) => args.map(Utils.parse[type]);\r\n  // operatorToValidator returns a validating function for an operator function, applied to the given type\r\n  let ValidatorRegistry__operatorToValidator = (type, operator) => {\r\n    return (value, ...requirementsAndInput) => {\r\n      requirementsAndInput.pop(); // Get rid of `input` argument\r\n      return operator(value, ...ValidatorRegistry__parseArguments(type, requirementsAndInput));\r\n    };\r\n  };\r\n\r\n  let ValidatorRegistry__comparisonOperator = operator => ({\r\n    validateDate: ValidatorRegistry__operatorToValidator('date', operator),\r\n    validateNumber: ValidatorRegistry__operatorToValidator('number', operator),\r\n    requirementType: operator.length <= 2 ? 'string' : ['string', 'string'], // Support operators with a 1 or 2 requirement(s)\r\n    priority: 30\r\n  });\r\n\r\n  ValidatorRegistry.prototype = {\r\n    init: function (validators, catalog) {\r\n      this.catalog = catalog;\r\n      // Copy prototype's validators:\r\n      this.validators = Object.assign({}, this.validators);\r\n\r\n      for (var name in validators)\r\n        this.addValidator(name, validators[name].fn, validators[name].priority);\r\n\r\n      window.Parsley.trigger('parsley:validator:init');\r\n    },\r\n\r\n    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\r\n    setLocale: function (locale) {\r\n      if ('undefined' === typeof this.catalog[locale])\r\n        throw new Error(locale + ' is not available in the catalog');\r\n\r\n      this.locale = locale;\r\n\r\n      return this;\r\n    },\r\n\r\n    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\r\n    addCatalog: function (locale, messages, set) {\r\n      if ('object' === typeof messages)\r\n        this.catalog[locale] = messages;\r\n\r\n      if (true === set)\r\n        return this.setLocale(locale);\r\n\r\n      return this;\r\n    },\r\n\r\n    // Add a specific message for a given constraint in a given locale\r\n    addMessage: function (locale, name, message) {\r\n      if ('undefined' === typeof this.catalog[locale])\r\n        this.catalog[locale] = {};\r\n\r\n      this.catalog[locale][name] = message;\r\n\r\n      return this;\r\n    },\r\n\r\n    // Add messages for a given locale\r\n    addMessages: function (locale, nameMessageObject) {\r\n      for (var name in nameMessageObject)\r\n        this.addMessage(locale, name, nameMessageObject[name]);\r\n\r\n      return this;\r\n    },\r\n\r\n    // Add a new validator\r\n    //\r\n    //    addValidator('custom', {\r\n    //        requirementType: ['integer', 'integer'],\r\n    //        validateString: function(value, from, to) {},\r\n    //        priority: 22,\r\n    //        messages: {\r\n    //          en: \"Hey, that's no good\",\r\n    //          fr: \"Aye aye, pas bon du tout\",\r\n    //        }\r\n    //    })\r\n    //\r\n    // Old API was addValidator(name, function, priority)\r\n    //\r\n    addValidator: function (name, arg1, arg2) {\r\n      if (this.validators[name])\r\n        Utils.warn('Validator \"' + name + '\" is already defined.');\r\n      else if (Defaults.hasOwnProperty(name)) {\r\n        Utils.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\r\n        return;\r\n      }\r\n      return this._setValidator(...arguments);\r\n    },\r\n\r\n    updateValidator: function (name, arg1, arg2) {\r\n      if (!this.validators[name]) {\r\n        Utils.warn('Validator \"' + name + '\" is not already defined.');\r\n        return this.addValidator(...arguments);\r\n      }\r\n      return this._setValidator(...arguments);\r\n    },\r\n\r\n    removeValidator: function (name) {\r\n      if (!this.validators[name])\r\n        Utils.warn('Validator \"' + name + '\" is not defined.');\r\n\r\n      delete this.validators[name];\r\n\r\n      return this;\r\n    },\r\n\r\n    _setValidator: function (name, validator, priority) {\r\n      if ('object' !== typeof validator) {\r\n        // Old style validator, with `fn` and `priority`\r\n        validator = {\r\n          fn: validator,\r\n          priority: priority\r\n        };\r\n      }\r\n      if (!validator.validate) {\r\n        validator = new Validator(validator);\r\n      }\r\n      this.validators[name] = validator;\r\n\r\n      for (var locale in validator.messages || {})\r\n        this.addMessage(locale, name, validator.messages[locale]);\r\n\r\n      return this;\r\n    },\r\n\r\n    getErrorMessage: function (constraint) {\r\n      var message;\r\n\r\n      // Type constraints are a bit different, we have to match their requirements too to find right error message\r\n      if ('type' === constraint.name) {\r\n        var typeMessages = this.catalog[this.locale][constraint.name] || {};\r\n        message = typeMessages[constraint.requirements];\r\n      } else\r\n        message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\r\n\r\n      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\r\n    },\r\n\r\n    // Kind of light `sprintf()` implementation\r\n    formatMessage: function (string, parameters) {\r\n      if ('object' === typeof parameters) {\r\n        for (var i in parameters)\r\n          string = this.formatMessage(string, parameters[i]);\r\n\r\n        return string;\r\n      }\r\n\r\n      return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\r\n    },\r\n\r\n    // Here is the Parsley default validators list.\r\n    // A validator is an object with the following key values:\r\n    //  - priority: an integer\r\n    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\r\n    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\r\n    // Alternatively, a validator can be a function that returns such an object\r\n    //\r\n    validators: {\r\n      notblank: {\r\n        validateString: function(value) {\r\n          return /\\S/.test(value);\r\n        },\r\n        priority: 2\r\n      },\r\n      required: {\r\n        validateMultiple: function(values) {\r\n          return values.length > 0;\r\n        },\r\n        validateString: function(value) {\r\n          return /\\S/.test(value);\r\n        },\r\n        priority: 512\r\n      },\r\n      type: {\r\n        validateString: function(value, type, {step = 'any', base = 0} = {}) {\r\n          var tester = typeTesters[type];\r\n          if (!tester) {\r\n            throw new Error('validator type `' + type + '` is not supported');\r\n          }\r\n          if (!tester.test(value))\r\n            return false;\r\n          if ('number' === type) {\r\n            if (!/^any$/i.test(step || '')) {\r\n              var nb = Number(value);\r\n              var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\r\n              if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\r\n                return false;\r\n              // Be careful of rounding errors by using integers.\r\n              var toInt = f => Math.round(f * Math.pow(10, decimals));\r\n              if ((toInt(nb) - toInt(base)) % toInt(step) != 0)\r\n                return false;\r\n            }\r\n          }\r\n          return true;\r\n        },\r\n        requirementType: {\r\n          '': 'string',\r\n          step: 'string',\r\n          base: 'number'\r\n        },\r\n        priority: 256\r\n      },\r\n      pattern: {\r\n        validateString: function(value, regexp) {\r\n          return regexp.test(value);\r\n        },\r\n        requirementType: 'regexp',\r\n        priority: 64\r\n      },\r\n      minlength: {\r\n        validateString: function (value, requirement) {\r\n          return value.length >= requirement;\r\n        },\r\n        requirementType: 'integer',\r\n        priority: 30\r\n      },\r\n      maxlength: {\r\n        validateString: function (value, requirement) {\r\n          return value.length <= requirement;\r\n        },\r\n        requirementType: 'integer',\r\n        priority: 30\r\n      },\r\n      length: {\r\n        validateString: function (value, min, max) {\r\n          return value.length >= min && value.length <= max;\r\n        },\r\n        requirementType: ['integer', 'integer'],\r\n        priority: 30\r\n      },\r\n      mincheck: {\r\n        validateMultiple: function (values, requirement) {\r\n          return values.length >= requirement;\r\n        },\r\n        requirementType: 'integer',\r\n        priority: 30\r\n      },\r\n      maxcheck: {\r\n        validateMultiple: function (values, requirement) {\r\n          return values.length <= requirement;\r\n        },\r\n        requirementType: 'integer',\r\n        priority: 30\r\n      },\r\n      check: {\r\n        validateMultiple: function (values, min, max) {\r\n          return values.length >= min && values.length <= max;\r\n        },\r\n        requirementType: ['integer', 'integer'],\r\n        priority: 30\r\n      },\r\n      min: ValidatorRegistry__comparisonOperator((value, requirement) => value >= requirement),\r\n      max: ValidatorRegistry__comparisonOperator((value, requirement) => value <= requirement),\r\n      range: ValidatorRegistry__comparisonOperator((value, min, max) => value >= min && value <= max),\r\n      equalto: {\r\n        validateString: function (value, refOrValue) {\r\n          var $reference = $(refOrValue);\r\n          if ($reference.length)\r\n            return value === $reference.val();\r\n          else\r\n            return value === refOrValue;\r\n        },\r\n        priority: 256\r\n      }\r\n    }\r\n  };\n\n  var UI = {};\r\n\r\n  var diffResults = function (newResult, oldResult, deep) {\r\n    var added = [];\r\n    var kept = [];\r\n\r\n    for (var i = 0; i < newResult.length; i++) {\r\n      var found = false;\r\n\r\n      for (var j = 0; j < oldResult.length; j++)\r\n        if (newResult[i].assert.name === oldResult[j].assert.name) {\r\n          found = true;\r\n          break;\r\n        }\r\n\r\n      if (found)\r\n        kept.push(newResult[i]);\r\n      else\r\n        added.push(newResult[i]);\r\n    }\r\n\r\n    return {\r\n      kept: kept,\r\n      added: added,\r\n      removed: !deep ? diffResults(oldResult, newResult, true).added : []\r\n    };\r\n  };\r\n\r\n  UI.Form = {\r\n\r\n    _actualizeTriggers: function () {\r\n      this.$element.on('submit.Parsley', evt => { this.onSubmitValidate(evt); });\r\n      this.$element.on('click.Parsley', Utils._SubmitSelector, evt => { this.onSubmitButton(evt); });\r\n\r\n      // UI could be disabled\r\n      if (false === this.options.uiEnabled)\r\n        return;\r\n\r\n      this.element.setAttribute('novalidate', '');\r\n    },\r\n\r\n    focus: function () {\r\n      this._focusedField = null;\r\n\r\n      if (true === this.validationResult || 'none' === this.options.focus)\r\n        return null;\r\n\r\n      for (var i = 0; i < this.fields.length; i++) {\r\n        var field = this.fields[i];\r\n        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\r\n          this._focusedField = field.$element;\r\n          if ('first' === this.options.focus)\r\n            break;\r\n        }\r\n      }\r\n\r\n      if (null === this._focusedField)\r\n        return null;\r\n\r\n      return this._focusedField.focus();\r\n    },\r\n\r\n    _destroyUI: function () {\r\n      // Reset all event listeners\r\n      this.$element.off('.Parsley');\r\n    }\r\n\r\n  };\r\n\r\n  UI.Field = {\r\n\r\n    _reflowUI: function ({silent} = {}) {\r\n      this._buildUI();\r\n\r\n      // If this field doesn't have an active UI don't bother doing something\r\n      if (!this._ui)\r\n        return;\r\n\r\n      // Diff between two validation results\r\n      var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\r\n\r\n      // Then store current validation result for next reflow\r\n      this._ui.lastValidationResult = this.validationResult;\r\n\r\n      // Handle valid / invalid / none field class\r\n      this._manageStatusClass();\r\n\r\n      // Add, remove, updated errors messages\r\n      if (!silent) this._manageErrorsMessages(diff);\r\n\r\n      // Triggers impl\r\n      this._actualizeTriggers();\r\n\r\n      // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\r\n      if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\r\n        this._failedOnce = true;\r\n        this._actualizeTriggers();\r\n      }\r\n    },\r\n\r\n    // Returns an array of field's error message(s)\r\n    getErrorsMessages: function () {\r\n      // No error message, field is valid\r\n      if (true === this.validationResult)\r\n        return [];\r\n\r\n      var messages = [];\r\n\r\n      for (var i = 0; i < this.validationResult.length; i++)\r\n        messages.push(this.validationResult[i].errorMessage ||\r\n         this._getErrorMessage(this.validationResult[i].assert));\r\n\r\n      return messages;\r\n    },\r\n\r\n    // It's a goal of Parsley that this method is no longer required [#1073]\r\n    addError: function (name, {message, assert, updateClass = true} = {}) {\r\n      this._buildUI();\r\n      this._addError(name, {message, assert});\r\n\r\n      if (updateClass)\r\n        this._errorClass();\r\n    },\r\n\r\n    // It's a goal of Parsley that this method is no longer required [#1073]\r\n    updateError: function (name, {message, assert, updateClass = true} = {}) {\r\n      this._buildUI();\r\n      this._updateError(name, {message, assert});\r\n\r\n      if (updateClass)\r\n        this._errorClass();\r\n    },\r\n\r\n    // It's a goal of Parsley that this method is no longer required [#1073]\r\n    removeError: function (name, {updateClass = true} = {}) {\r\n      this._buildUI();\r\n      this._removeError(name);\r\n\r\n      // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\r\n      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\r\n      if (updateClass)\r\n        this._manageStatusClass();\r\n    },\r\n\r\n    _manageStatusClass: function () {\r\n      if (this.hasConstraints() && this.needsValidation() && true === this.validationResult)\r\n        this._successClass();\r\n      else if (this.validationResult.length > 0)\r\n        this._errorClass();\r\n      else\r\n        this._resetClass();\r\n    },\r\n\r\n    _manageErrorsMessages: function (diff) {\r\n      if ('undefined' !== typeof this.options.errorsMessagesDisabled)\r\n        return;\r\n\r\n      // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\r\n      if ('undefined' !== typeof this.options.errorMessage) {\r\n        if ((diff.added.length || diff.kept.length)) {\r\n          this._insertErrorWrapper();\r\n\r\n          if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length)\r\n            this._ui.$errorsWrapper\r\n              .append(\r\n                $(this.options.errorTemplate)\r\n                .addClass('parsley-custom-error-message')\r\n              );\r\n\r\n          return this._ui.$errorsWrapper\r\n            .addClass('filled')\r\n            .find('.parsley-custom-error-message')\r\n            .html(this.options.errorMessage);\r\n        }\r\n\r\n        return this._ui.$errorsWrapper\r\n          .removeClass('filled')\r\n          .find('.parsley-custom-error-message')\r\n          .remove();\r\n      }\r\n\r\n      // Show, hide, update failing constraints messages\r\n      for (var i = 0; i < diff.removed.length; i++)\r\n        this._removeError(diff.removed[i].assert.name);\r\n\r\n      for (i = 0; i < diff.added.length; i++)\r\n        this._addError(diff.added[i].assert.name, {message: diff.added[i].errorMessage, assert: diff.added[i].assert});\r\n\r\n      for (i = 0; i < diff.kept.length; i++)\r\n        this._updateError(diff.kept[i].assert.name, {message: diff.kept[i].errorMessage, assert: diff.kept[i].assert});\r\n    },\r\n\r\n\r\n    _addError: function (name, {message, assert}) {\r\n      this._insertErrorWrapper();\r\n      this._ui.$errorsWrapper\r\n        .addClass('filled')\r\n        .append(\r\n          $(this.options.errorTemplate)\r\n          .addClass('parsley-' + name)\r\n          .html(message || this._getErrorMessage(assert))\r\n        );\r\n    },\r\n\r\n    _updateError: function (name, {message, assert}) {\r\n      this._ui.$errorsWrapper\r\n        .addClass('filled')\r\n        .find('.parsley-' + name)\r\n        .html(message || this._getErrorMessage(assert));\r\n    },\r\n\r\n    _removeError: function (name) {\r\n      this._ui.$errorsWrapper\r\n        .removeClass('filled')\r\n        .find('.parsley-' + name)\r\n        .remove();\r\n    },\r\n\r\n    _getErrorMessage: function (constraint) {\r\n      var customConstraintErrorMessage = constraint.name + 'Message';\r\n\r\n      if ('undefined' !== typeof this.options[customConstraintErrorMessage])\r\n        return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\r\n\r\n      return window.Parsley.getErrorMessage(constraint);\r\n    },\r\n\r\n    _buildUI: function () {\r\n      // UI could be already built or disabled\r\n      if (this._ui || false === this.options.uiEnabled)\r\n        return;\r\n\r\n      var _ui = {};\r\n\r\n      // Give field its Parsley id in DOM\r\n      this.element.setAttribute(this.options.namespace + 'id', this.__id__);\r\n\r\n      /** Generate important UI elements and store them in this **/\r\n      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\r\n      _ui.$errorClassHandler = this._manageClassHandler();\r\n\r\n      // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\r\n      _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\r\n      _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\r\n\r\n      // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\r\n      _ui.lastValidationResult = [];\r\n      _ui.validationInformationVisible = false;\r\n\r\n      // Store it in this for later\r\n      this._ui = _ui;\r\n    },\r\n\r\n    // Determine which element will have `parsley-error` and `parsley-success` classes\r\n    _manageClassHandler: function () {\r\n      // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\r\n      if ('string' === typeof this.options.classHandler) {\r\n        if ($(this.options.classHandler).length === 0)\r\n          ParsleyUtils.warn('No elements found that match the selector `' + this.options.classHandler + '` set in options.classHandler or data-parsley-class-handler');\r\n\r\n        //return element or empty set\r\n        return $(this.options.classHandler);\r\n      }\r\n\r\n      // Class handled could also be determined by function given in Parsley options\r\n      if ('function' === typeof this.options.classHandler)\r\n        var $handler = this.options.classHandler.call(this, this);\r\n\r\n      // If this function returned a valid existing DOM element, go for it\r\n      if ('undefined' !== typeof $handler && $handler.length)\r\n        return $handler;\r\n\r\n      return this._inputHolder();\r\n    },\r\n\r\n    _inputHolder: function() {\r\n      // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\r\n      if (!this.options.multiple || this.element.nodeName === 'SELECT')\r\n        return this.$element;\r\n\r\n      // But if multiple element (radio, checkbox), that would be their parent\r\n      return this.$element.parent();\r\n    },\r\n\r\n    _insertErrorWrapper: function () {\r\n      var $errorsContainer;\r\n\r\n      // Nothing to do if already inserted\r\n      if (0 !== this._ui.$errorsWrapper.parent().length)\r\n        return this._ui.$errorsWrapper.parent();\r\n\r\n      if ('string' === typeof this.options.errorsContainer) {\r\n        if ($(this.options.errorsContainer).length)\r\n          return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);\r\n        else\r\n          Utils.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\r\n      } else if ('function' === typeof this.options.errorsContainer)\r\n        $errorsContainer = this.options.errorsContainer.call(this, this);\r\n\r\n      if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)\r\n        return $errorsContainer.append(this._ui.$errorsWrapper);\r\n\r\n      return this._inputHolder().after(this._ui.$errorsWrapper);\r\n    },\r\n\r\n    _actualizeTriggers: function () {\r\n      var $toBind = this._findRelated();\r\n      var trigger;\r\n\r\n      // Remove Parsley events already bound on this field\r\n      $toBind.off('.Parsley');\r\n      if (this._failedOnce)\r\n        $toBind.on(Utils.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), () => {\r\n          this._validateIfNeeded();\r\n        });\r\n      else if (trigger = Utils.namespaceEvents(this.options.trigger, 'Parsley')) {\r\n        $toBind.on(trigger, event => {\r\n          this._validateIfNeeded(event);\r\n        });\r\n      }\r\n    },\r\n\r\n    _validateIfNeeded: function (event) {\r\n      // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\r\n      // do not validate if val length < min threshold on first validation. Once field have been validated once and info\r\n      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\r\n      if (event && /key|input/.test(event.type))\r\n        if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold)\r\n          return;\r\n\r\n      if (this.options.debounce) {\r\n        window.clearTimeout(this._debounced);\r\n        this._debounced = window.setTimeout(() => this.validate(), this.options.debounce);\r\n      } else\r\n        this.validate();\r\n    },\r\n\r\n    _resetUI: function () {\r\n      // Reset all event listeners\r\n      this._failedOnce = false;\r\n      this._actualizeTriggers();\r\n\r\n      // Nothing to do if UI never initialized for this field\r\n      if ('undefined' === typeof this._ui)\r\n        return;\r\n\r\n      // Reset all errors' li\r\n      this._ui.$errorsWrapper\r\n        .removeClass('filled')\r\n        .children()\r\n        .remove();\r\n\r\n      // Reset validation class\r\n      this._resetClass();\r\n\r\n      // Reset validation flags and last validation result\r\n      this._ui.lastValidationResult = [];\r\n      this._ui.validationInformationVisible = false;\r\n    },\r\n\r\n    _destroyUI: function () {\r\n      this._resetUI();\r\n\r\n      if ('undefined' !== typeof this._ui)\r\n        this._ui.$errorsWrapper.remove();\r\n\r\n      delete this._ui;\r\n    },\r\n\r\n    _successClass: function () {\r\n      this._ui.validationInformationVisible = true;\r\n      this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\r\n    },\r\n    _errorClass: function () {\r\n      this._ui.validationInformationVisible = true;\r\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\r\n    },\r\n    _resetClass: function () {\r\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\r\n    }\r\n  };\n\n  var Form = function (element, domOptions, options) {\r\n    this.__class__ = 'Form';\r\n\r\n    this.element = element;\r\n    this.$element = $(element);\r\n    this.domOptions = domOptions;\r\n    this.options = options;\r\n    this.parent = window.Parsley;\r\n\r\n    this.fields = [];\r\n    this.validationResult = null;\r\n  };\r\n\r\n  var Form__statusMapping = {pending: null, resolved: true, rejected: false};\r\n\r\n  Form.prototype = {\r\n    onSubmitValidate: function (event) {\r\n      // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\r\n      if (true === event.parsley)\r\n        return;\r\n\r\n      // If we didn't come here through a submit button, use the first one in the form\r\n      var submitSource = this._submitSource || this.$element.find(Utils._SubmitSelector)[0];\r\n      this._submitSource = null;\r\n      this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\r\n      if (submitSource && null !== submitSource.getAttribute('formnovalidate'))\r\n        return;\r\n\r\n      window.Parsley._remoteCache = {};\r\n\r\n      var promise = this.whenValidate({event});\r\n\r\n      if ('resolved' === promise.state() && false !== this._trigger('submit')) {\r\n        // All good, let event go through. We make this distinction because browsers\r\n        // differ in their handling of `submit` being called from inside a submit event [#1047]\r\n      } else {\r\n        // Rejected or pending: cancel this submit\r\n        event.stopImmediatePropagation();\r\n        event.preventDefault();\r\n        if ('pending' === promise.state())\r\n          promise.done(() => { this._submit(submitSource); });\r\n      }\r\n    },\r\n\r\n    onSubmitButton: function(event) {\r\n      this._submitSource = event.currentTarget;\r\n    },\r\n    // internal\r\n    // _submit submits the form, this time without going through the validations.\r\n    // Care must be taken to \"fake\" the actual submit button being clicked.\r\n    _submit: function (submitSource) {\r\n      if (false === this._trigger('submit'))\r\n        return;\r\n      // Add submit button's data\r\n      if (submitSource) {\r\n        var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\r\n        if (0 === $synthetic.length)\r\n          $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\r\n        $synthetic.attr({\r\n          name: submitSource.getAttribute('name'),\r\n          value: submitSource.getAttribute('value')\r\n        });\r\n      }\r\n\r\n      this.$element.trigger(Object.assign($.Event('submit'), {parsley: true}));\r\n    },\r\n\r\n    // Performs validation on fields while triggering events.\r\n    // @returns `true` if all validations succeeds, `false`\r\n    // if a failure is immediately detected, or `null`\r\n    // if dependant on a promise.\r\n    // Consider using `whenValidate` instead.\r\n    validate: function (options) {\r\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n        Utils.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\r\n        var [group, force, silent, event] = arguments;\r\n        options = {group, force, silent, event};\r\n      }\r\n      return Form__statusMapping[ this.whenValidate(options).state() ];\r\n    },\r\n\r\n    whenValidate: function ({group, force, silent, event} = {}) {\r\n      this.submitEvent = event;\r\n      if (event) {\r\n        this.submitEvent = Object.assign({}, event, {preventDefault: () => {\r\n          Utils.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\r\n          this.validationResult = false;\r\n        }});\r\n      }\r\n      this.validationResult = true;\r\n\r\n      // fire validate event to eventually modify things before every validation\r\n      this._trigger('validate');\r\n\r\n      // Refresh form DOM options and form's fields that could have changed\r\n      this._refreshFields();\r\n\r\n      var promises = this._withoutReactualizingFormOptions(() => {\r\n        return $.map(this.fields, field => field.whenValidate({force, group, silent}));\r\n      });\r\n\r\n      return Utils.all(promises)\r\n        .done(  () => { this._trigger('success'); })\r\n        .fail(  () => {\r\n          this.validationResult = false;\r\n          if (!silent) this.focus();\r\n          this._trigger('error');\r\n        })\r\n        .always(() => { this._trigger('validated'); })\r\n        .pipe(...this._pipeAccordingToValidationResult());\r\n    },\r\n\r\n    // Iterate over refreshed fields, and stop on first failure.\r\n    // Returns `true` if all fields are valid, `false` if a failure is detected\r\n    // or `null` if the result depends on an unresolved promise.\r\n    // Prefer using `whenValid` instead.\r\n    isValid: function (options) {\r\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n        Utils.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\r\n        var [group, force] = arguments;\r\n        options = {group, force};\r\n      }\r\n      return Form__statusMapping[ this.whenValid(options).state() ];\r\n    },\r\n\r\n    // Iterate over refreshed fields and validate them.\r\n    // Returns a promise.\r\n    // A validation that immediately fails will interrupt the validations.\r\n    whenValid: function ({group, force} = {}) {\r\n      this._refreshFields();\r\n\r\n      var promises = this._withoutReactualizingFormOptions(() => {\r\n        return $.map(this.fields, field => field.whenValid({group, force}));\r\n      });\r\n      return Utils.all(promises);\r\n    },\r\n\r\n    // Reset UI\r\n    reset: function () {\r\n      // Form case: emit a reset event for each field\r\n      for (var i = 0; i < this.fields.length; i++)\r\n        this.fields[i].reset();\r\n\r\n      this._trigger('reset');\r\n    },\r\n\r\n    // Destroy Parsley instance (+ UI)\r\n    destroy: function () {\r\n      // Field case: emit destroy event to clean UI and then destroy stored instance\r\n      this._destroyUI();\r\n\r\n      // Form case: destroy all its fields and then destroy stored instance\r\n      for (var i = 0; i < this.fields.length; i++)\r\n        this.fields[i].destroy();\r\n\r\n      this.$element.removeData('Parsley');\r\n      this._trigger('destroy');\r\n    },\r\n\r\n    _refreshFields: function () {\r\n      return this.actualizeOptions()._bindFields();\r\n    },\r\n\r\n    _bindFields: function () {\r\n      var oldFields = this.fields;\r\n\r\n      this.fields = [];\r\n      this.fieldsMappedById = {};\r\n\r\n      this._withoutReactualizingFormOptions(() => {\r\n        this.$element\r\n        .find(this.options.inputs)\r\n        .not(this.options.excluded)\r\n        .each((_, element) => {\r\n          var fieldInstance = new window.Parsley.Factory(element, {}, this);\r\n\r\n          // Only add valid and not excluded `Field` and `FieldMultiple` children\r\n          if (('Field' === fieldInstance.__class__ || 'FieldMultiple' === fieldInstance.__class__) && (true !== fieldInstance.options.excluded)) {\r\n            let uniqueId = fieldInstance.__class__ + '-' + fieldInstance.__id__;\r\n            if ('undefined' === typeof this.fieldsMappedById[uniqueId]) {\r\n              this.fieldsMappedById[uniqueId] = fieldInstance;\r\n              this.fields.push(fieldInstance);\r\n            }\r\n          }\r\n        });\r\n\r\n        $.each(Utils.difference(oldFields, this.fields), (_, field) => {\r\n          field.reset();\r\n        });\r\n      });\r\n      return this;\r\n    },\r\n\r\n    // Internal only.\r\n    // Looping on a form's fields to do validation or similar\r\n    // will trigger reactualizing options on all of them, which\r\n    // in turn will reactualize the form's options.\r\n    // To avoid calling actualizeOptions so many times on the form\r\n    // for nothing, _withoutReactualizingFormOptions temporarily disables\r\n    // the method actualizeOptions on this form while `fn` is called.\r\n    _withoutReactualizingFormOptions: function (fn) {\r\n      var oldActualizeOptions = this.actualizeOptions;\r\n      this.actualizeOptions = function () { return this; };\r\n      var result = fn();\r\n      this.actualizeOptions = oldActualizeOptions;\r\n      return result;\r\n    },\r\n\r\n    // Internal only.\r\n    // Shortcut to trigger an event\r\n    // Returns true iff event is not interrupted and default not prevented.\r\n    _trigger: function (eventName) {\r\n      return this.trigger('form:' + eventName);\r\n    }\r\n\r\n  };\n\n  const Constraint = function(parsleyField, name, requirements, priority, isDomConstraint) {\r\n    const validatorSpec = window.Parsley._validatorRegistry.validators[name];\r\n    const validator = new Validator(validatorSpec);\r\n    priority = priority || parsleyField.options[name + 'Priority'] || validator.priority;\r\n    isDomConstraint = (true === isDomConstraint);\r\n\r\n    Object.assign(this, {\r\n      validator,\r\n      name,\r\n      requirements,\r\n      priority,\r\n      isDomConstraint\r\n    });\r\n    this._parseRequirements(parsleyField.options);\r\n  };\r\n\r\n  const capitalize = function(str) {\r\n    const cap = str[0].toUpperCase();\r\n    return cap + str.slice(1);\r\n  };\r\n\r\n  Constraint.prototype = {\r\n    validate: function(value, instance) {\r\n      return this.validator.validate(value, ...this.requirementList, instance);\r\n    },\r\n\r\n    _parseRequirements: function(options) {\r\n      this.requirementList = this.validator.parseRequirements(this.requirements,\r\n        key => options[this.name + capitalize(key)]\r\n      );\r\n    }\r\n  };\n\n  var Field = function (field, domOptions, options, parsleyFormInstance) {\r\n    this.__class__ = 'Field';\r\n\r\n    this.element = field;\r\n    this.$element = $(field);\r\n\r\n    // Set parent if we have one\r\n    if ('undefined' !== typeof parsleyFormInstance) {\r\n      this.parent = parsleyFormInstance;\r\n    }\r\n\r\n    this.options = options;\r\n    this.domOptions = domOptions;\r\n\r\n    // Initialize some properties\r\n    this.constraints = [];\r\n    this.constraintsByName = {};\r\n    this.validationResult = true;\r\n\r\n    // Bind constraints\r\n    this._bindConstraints();\r\n  };\r\n\r\n  var parsley_field__statusMapping = {pending: null, resolved: true, rejected: false};\r\n\r\n  Field.prototype = {\r\n    // # Public API\r\n    // Validate field and trigger some events for mainly `UI`\r\n    // @returns `true`, an array of the validators that failed, or\r\n    // `null` if validation is not finished. Prefer using whenValidate\r\n    validate: function (options) {\r\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n        Utils.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\r\n        options = {options};\r\n      }\r\n      var promise = this.whenValidate(options);\r\n      if (!promise)  // If excluded with `group` option\r\n        return true;\r\n      switch (promise.state()) {\r\n        case 'pending': return null;\r\n        case 'resolved': return true;\r\n        case 'rejected': return this.validationResult;\r\n      }\r\n    },\r\n\r\n    // Validate field and trigger some events for mainly `UI`\r\n    // @returns a promise that succeeds only when all validations do\r\n    // or `undefined` if field is not in the given `group`.\r\n    whenValidate: function ({force, group, silent} =  {}) {\r\n      // do not validate a field if not the same as given validation group\r\n      this.refreshConstraints();\r\n      if (group && !this._isInGroup(group))\r\n        return;\r\n\r\n      this.value = this.getValue();\r\n\r\n      // Field Validate event. `this.value` could be altered for custom needs\r\n      this._trigger('validate');\r\n\r\n      return this.whenValid({force, value: this.value, _refreshed: true})\r\n        .always(() => { this._reflowUI({silent}); })\r\n        .done(() =>   { this._trigger('success'); })\r\n        .fail(() =>   { this._trigger('error'); })\r\n        .always(() => { this._trigger('validated'); })\r\n        .pipe(...this._pipeAccordingToValidationResult());\r\n    },\r\n\r\n    hasConstraints: function () {\r\n      return 0 !== this.constraints.length;\r\n    },\r\n\r\n    // An empty optional field does not need validation\r\n    needsValidation: function (value) {\r\n      if ('undefined' === typeof value)\r\n        value = this.getValue();\r\n\r\n      // If a field is empty and not required, it is valid\r\n      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\r\n      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty)\r\n        return false;\r\n\r\n      return true;\r\n    },\r\n\r\n    _isInGroup: function (group) {\r\n      if (Array.isArray(this.options.group))\r\n        return -1 !== $.inArray(group, this.options.group);\r\n      return this.options.group === group;\r\n    },\r\n\r\n    // Just validate field. Do not trigger any event.\r\n    // Returns `true` iff all constraints pass, `false` if there are failures,\r\n    // or `null` if the result can not be determined yet (depends on a promise)\r\n    // See also `whenValid`.\r\n    isValid: function (options) {\r\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n        Utils.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\r\n        var [force, value] = arguments;\r\n        options = {force, value};\r\n      }\r\n      var promise = this.whenValid(options);\r\n      if (!promise) // Excluded via `group`\r\n        return true;\r\n      return parsley_field__statusMapping[promise.state()];\r\n    },\r\n\r\n    // Just validate field. Do not trigger any event.\r\n    // @returns a promise that succeeds only when all validations do\r\n    // or `undefined` if the field is not in the given `group`.\r\n    // The argument `force` will force validation of empty fields.\r\n    // If a `value` is given, it will be validated instead of the value of the input.\r\n    whenValid: function ({force = false, value, group, _refreshed} = {}) {\r\n      // Recompute options and rebind constraints to have latest changes\r\n      if (!_refreshed)\r\n        this.refreshConstraints();\r\n      // do not validate a field if not the same as given validation group\r\n      if (group && !this._isInGroup(group))\r\n        return;\r\n\r\n      this.validationResult = true;\r\n\r\n      // A field without constraint is valid\r\n      if (!this.hasConstraints())\r\n        return $.when();\r\n\r\n      // Value could be passed as argument, needed to add more power to 'field:validate'\r\n      if ('undefined' === typeof value || null === value)\r\n        value = this.getValue();\r\n\r\n      if (!this.needsValidation(value) && true !== force)\r\n        return $.when();\r\n\r\n      var groupedConstraints = this._getGroupedConstraints();\r\n      var promises = [];\r\n      $.each(groupedConstraints, (_, constraints) => {\r\n        // Process one group of constraints at a time, we validate the constraints\r\n        // and combine the promises together.\r\n        var promise = Utils.all(\r\n          $.map(constraints, constraint => this._validateConstraint(value, constraint))\r\n        );\r\n        promises.push(promise);\r\n        if (promise.state() === 'rejected')\r\n          return false; // Interrupt processing if a group has already failed\r\n      });\r\n      return Utils.all(promises);\r\n    },\r\n\r\n    // @returns a promise\r\n    _validateConstraint: function(value, constraint) {\r\n      var result = constraint.validate(value, this);\r\n      // Map false to a failed promise\r\n      if (false === result)\r\n        result = $.Deferred().reject();\r\n      // Make sure we return a promise and that we record failures\r\n      return Utils.all([result]).fail(errorMessage => {\r\n        if (!(this.validationResult instanceof Array))\r\n          this.validationResult = [];\r\n        this.validationResult.push({\r\n          assert: constraint,\r\n          errorMessage: 'string' === typeof errorMessage && errorMessage\r\n        });\r\n      });\r\n    },\r\n\r\n    // @returns Parsley field computed value that could be overrided or configured in DOM\r\n    getValue: function () {\r\n      var value;\r\n\r\n      // Value could be overriden in DOM or with explicit options\r\n      if ('function' === typeof this.options.value)\r\n        value = this.options.value(this);\r\n      else if ('undefined' !== typeof this.options.value)\r\n        value = this.options.value;\r\n      else\r\n        value = this.$element.val();\r\n\r\n      // Handle wrong DOM or configurations\r\n      if ('undefined' === typeof value || null === value)\r\n        return '';\r\n\r\n      return this._handleWhitespace(value);\r\n    },\r\n\r\n    // Reset UI\r\n    reset: function () {\r\n      this._resetUI();\r\n      return this._trigger('reset');\r\n    },\r\n\r\n    // Destroy Parsley instance (+ UI)\r\n    destroy: function () {\r\n      // Field case: emit destroy event to clean UI and then destroy stored instance\r\n      this._destroyUI();\r\n      this.$element.removeData('Parsley');\r\n      this.$element.removeData('FieldMultiple');\r\n      this._trigger('destroy');\r\n    },\r\n\r\n    // Actualize options that could have change since previous validation\r\n    // Re-bind accordingly constraints (could be some new, removed or updated)\r\n    refreshConstraints: function () {\r\n      return this.actualizeOptions()._bindConstraints();\r\n    },\r\n\r\n    /**\r\n    * Add a new constraint to a field\r\n    *\r\n    * @param {String}   name\r\n    * @param {Mixed}    requirements      optional\r\n    * @param {Number}   priority          optional\r\n    * @param {Boolean}  isDomConstraint   optional\r\n    */\r\n    addConstraint: function (name, requirements, priority, isDomConstraint) {\r\n\r\n      if (window.Parsley._validatorRegistry.validators[name]) {\r\n        var constraint = new Constraint(this, name, requirements, priority, isDomConstraint);\r\n\r\n        // if constraint already exist, delete it and push new version\r\n        if ('undefined' !== this.constraintsByName[constraint.name])\r\n          this.removeConstraint(constraint.name);\r\n\r\n        this.constraints.push(constraint);\r\n        this.constraintsByName[constraint.name] = constraint;\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    // Remove a constraint\r\n    removeConstraint: function (name) {\r\n      for (var i = 0; i < this.constraints.length; i++)\r\n        if (name === this.constraints[i].name) {\r\n          this.constraints.splice(i, 1);\r\n          break;\r\n        }\r\n      delete this.constraintsByName[name];\r\n      return this;\r\n    },\r\n\r\n    // Update a constraint (Remove + re-add)\r\n    updateConstraint: function (name, parameters, priority) {\r\n      return this.removeConstraint(name)\r\n        .addConstraint(name, parameters, priority);\r\n    },\r\n\r\n    // # Internals\r\n\r\n    // Internal only.\r\n    // Bind constraints from config + options + DOM\r\n    _bindConstraints: function () {\r\n      var constraints = [];\r\n      var constraintsByName = {};\r\n\r\n      // clean all existing DOM constraints to only keep javascript user constraints\r\n      for (var i = 0; i < this.constraints.length; i++)\r\n        if (false === this.constraints[i].isDomConstraint) {\r\n          constraints.push(this.constraints[i]);\r\n          constraintsByName[this.constraints[i].name] = this.constraints[i];\r\n        }\r\n\r\n      this.constraints = constraints;\r\n      this.constraintsByName = constraintsByName;\r\n\r\n      // then re-add Parsley DOM-API constraints\r\n      for (var name in this.options)\r\n        this.addConstraint(name, this.options[name], undefined, true);\r\n\r\n      // finally, bind special HTML5 constraints\r\n      return this._bindHtml5Constraints();\r\n    },\r\n\r\n    // Internal only.\r\n    // Bind specific HTML5 constraints to be HTML5 compliant\r\n    _bindHtml5Constraints: function () {\r\n      // html5 required\r\n      if (null !== this.element.getAttribute('required'))\r\n        this.addConstraint('required', true, undefined, true);\r\n\r\n      // html5 pattern\r\n      if (null !== this.element.getAttribute('pattern'))\r\n        this.addConstraint('pattern', this.element.getAttribute('pattern'), undefined, true);\r\n\r\n      // range\r\n      let min = this.element.getAttribute('min');\r\n      let max = this.element.getAttribute('max');\r\n      if (null !== min && null !== max)\r\n        this.addConstraint('range', [min, max], undefined, true);\r\n\r\n      // HTML5 min\r\n      else if (null !== min)\r\n        this.addConstraint('min', min, undefined, true);\r\n\r\n      // HTML5 max\r\n      else if (null !== max)\r\n        this.addConstraint('max', max, undefined, true);\r\n\r\n\r\n      // length\r\n      if (null !== this.element.getAttribute('minlength') && null !== this.element.getAttribute('maxlength'))\r\n        this.addConstraint('length', [this.element.getAttribute('minlength'), this.element.getAttribute('maxlength')], undefined, true);\r\n\r\n      // HTML5 minlength\r\n      else if (null !== this.element.getAttribute('minlength'))\r\n        this.addConstraint('minlength', this.element.getAttribute('minlength'), undefined, true);\r\n\r\n      // HTML5 maxlength\r\n      else if (null !== this.element.getAttribute('maxlength'))\r\n        this.addConstraint('maxlength', this.element.getAttribute('maxlength'), undefined, true);\r\n\r\n\r\n      // html5 types\r\n      var type = this.element.type;\r\n\r\n      // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\r\n      if ('number' === type) {\r\n        return this.addConstraint('type', ['number', {\r\n          step: this.element.getAttribute('step') || '1',\r\n          base: min || this.element.getAttribute('value')\r\n        }], undefined, true);\r\n      // Regular other HTML5 supported types\r\n      } else if (/^(email|url|range|date)$/i.test(type)) {\r\n        return this.addConstraint('type', type, undefined, true);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Internal only.\r\n    // Field is required if have required constraint without `false` value\r\n    _isRequired: function () {\r\n      if ('undefined' === typeof this.constraintsByName.required)\r\n        return false;\r\n\r\n      return false !== this.constraintsByName.required.requirements;\r\n    },\r\n\r\n    // Internal only.\r\n    // Shortcut to trigger an event\r\n    _trigger: function (eventName) {\r\n      return this.trigger('field:' + eventName);\r\n    },\r\n\r\n    // Internal only\r\n    // Handles whitespace in a value\r\n    // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\r\n    // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\r\n    _handleWhitespace: function (value) {\r\n      if (true === this.options.trimValue)\r\n        Utils.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\r\n\r\n      if ('squish' === this.options.whitespace)\r\n        value = value.replace(/\\s{2,}/g, ' ');\r\n\r\n      if (('trim' === this.options.whitespace) || ('squish' === this.options.whitespace) || (true === this.options.trimValue))\r\n        value = Utils.trimString(value);\r\n\r\n      return value;\r\n    },\r\n\r\n    _isDateInput: function() {\r\n      var c = this.constraintsByName.type;\r\n      return c && c.requirements === 'date';\r\n    },\r\n\r\n    // Internal only.\r\n    // Returns the constraints, grouped by descending priority.\r\n    // The result is thus an array of arrays of constraints.\r\n    _getGroupedConstraints: function () {\r\n      if (false === this.options.priorityEnabled)\r\n        return [this.constraints];\r\n\r\n      var groupedConstraints = [];\r\n      var index = {};\r\n\r\n      // Create array unique of priorities\r\n      for (var i = 0; i < this.constraints.length; i++) {\r\n        var p = this.constraints[i].priority;\r\n        if (!index[p])\r\n          groupedConstraints.push(index[p] = []);\r\n        index[p].push(this.constraints[i]);\r\n      }\r\n      // Sort them by priority DESC\r\n      groupedConstraints.sort(function (a, b) { return b[0].priority - a[0].priority; });\r\n\r\n      return groupedConstraints;\r\n    }\r\n\r\n  };\r\n\r\n  var parsley_field = Field;\n\n  var Multiple = function () {\r\n    this.__class__ = 'FieldMultiple';\r\n  };\r\n\r\n  Multiple.prototype = {\r\n    // Add new `$element` sibling for multiple field\r\n    addElement: function ($element) {\r\n      this.$elements.push($element);\r\n\r\n      return this;\r\n    },\r\n\r\n    // See `Field.refreshConstraints()`\r\n    refreshConstraints: function () {\r\n      var fieldConstraints;\r\n\r\n      this.constraints = [];\r\n\r\n      // Select multiple special treatment\r\n      if (this.element.nodeName === 'SELECT') {\r\n        this.actualizeOptions()._bindConstraints();\r\n\r\n        return this;\r\n      }\r\n\r\n      // Gather all constraints for each input in the multiple group\r\n      for (var i = 0; i < this.$elements.length; i++) {\r\n\r\n        // Check if element have not been dynamically removed since last binding\r\n        if (!$('html').has(this.$elements[i]).length) {\r\n          this.$elements.splice(i, 1);\r\n          continue;\r\n        }\r\n\r\n        fieldConstraints = this.$elements[i].data('FieldMultiple').refreshConstraints().constraints;\r\n\r\n        for (var j = 0; j < fieldConstraints.length; j++)\r\n          this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    // See `Field.getValue()`\r\n    getValue: function () {\r\n      // Value could be overriden in DOM\r\n      if ('function' === typeof this.options.value)\r\n        return this.options.value(this);\r\n      else if ('undefined' !== typeof this.options.value)\r\n        return this.options.value;\r\n\r\n      // Radio input case\r\n      if (this.element.nodeName === 'INPUT') {\r\n        if (this.element.type === 'radio')\r\n          return this._findRelated().filter(':checked').val() || '';\r\n\r\n        // checkbox input case\r\n        if (this.element.type === 'checkbox') {\r\n          var values = [];\r\n\r\n          this._findRelated().filter(':checked').each(function () {\r\n            values.push($(this).val());\r\n          });\r\n\r\n          return values;\r\n        }\r\n      }\r\n\r\n      // Select multiple case\r\n      if (this.element.nodeName === 'SELECT' && null === this.$element.val())\r\n        return [];\r\n\r\n      // Default case that should never happen\r\n      return this.$element.val();\r\n    },\r\n\r\n    _init: function () {\r\n      this.$elements = [this.$element];\r\n\r\n      return this;\r\n    }\r\n  };\n\n  var Factory = function (element, options, parsleyFormInstance) {\r\n    this.element = element;\r\n    this.$element = $(element);\r\n\r\n    // If the element has already been bound, returns its saved Parsley instance\r\n    var savedparsleyFormInstance = this.$element.data('Parsley');\r\n    if (savedparsleyFormInstance) {\r\n\r\n      // If the saved instance has been bound without a Form parent and there is one given in this call, add it\r\n      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\r\n        savedparsleyFormInstance.parent = parsleyFormInstance;\r\n        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\r\n      }\r\n\r\n      if ('object' === typeof options) {\r\n        Object.assign(savedparsleyFormInstance.options, options);\r\n      }\r\n\r\n      // return\r\n      return savedparsleyFormInstance;\r\n    }\r\n\r\n    // Parsley must be instantiated with a DOM element or jQuery $element\r\n    if (!this.$element.length)\r\n      throw new Error('You must bind Parsley on an existing element.');\r\n\r\n    if ('undefined' !== typeof parsleyFormInstance && 'Form' !== parsleyFormInstance.__class__)\r\n      throw new Error('Parent instance must be a Form instance');\r\n\r\n    this.parent = parsleyFormInstance || window.Parsley;\r\n\r\n    // return\r\n    return this.init(options);\r\n  };\r\n\r\n  Factory.prototype = {\r\n    init: function (options) {\r\n      this.__class__ = 'Parsley';\r\n      this.__version__ = '2.7.3';\r\n      this.__id__ = Utils.generateID();\r\n\r\n      // Pre-compute options\r\n      this._resetOptions(options);\r\n\r\n      // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\r\n      if (this.element.nodeName === 'FORM' || (Utils.checkAttr(this.element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))\r\n        return this.bind('parsleyForm');\r\n\r\n      // Every other element is bound as a `Field` or `FieldMultiple`\r\n      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\r\n    },\r\n\r\n    isMultiple: function () {\r\n      return ((this.element.type === 'radio' || this.element.type === 'checkbox') ||\r\n        (this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple')));\r\n    },\r\n\r\n    // Multiples fields are a real nightmare :(\r\n    // Maybe some refactoring would be appreciated here...\r\n    handleMultiple: function () {\r\n      var name;\r\n      var multiple;\r\n      var parsleyMultipleInstance;\r\n\r\n      // Handle multiple name\r\n      this.options.multiple = this.options.multiple ||\r\n        (name = this.element.getAttribute('name')) ||\r\n        this.element.getAttribute('id');\r\n\r\n      // Special select multiple input\r\n      if (this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple')) {\r\n        this.options.multiple = this.options.multiple || this.__id__;\r\n        return this.bind('parsleyFieldMultiple');\r\n\r\n      // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\r\n      } else if (!this.options.multiple) {\r\n        Utils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\r\n        return this;\r\n      }\r\n\r\n      // Remove special chars\r\n      this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\r\n\r\n      // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\r\n      if (name) {\r\n        $('input[name=\"' + name + '\"]').each((i, input) => {\r\n          if ((input.type === 'radio' || input.type === 'checkbox'))\r\n            input.setAttribute(this.options.namespace + 'multiple', this.options.multiple);\r\n        });\r\n      }\r\n\r\n      // Check here if we don't already have a related multiple instance saved\r\n      var $previouslyRelated = this._findRelated();\r\n      for (var i = 0; i < $previouslyRelated.length; i++) {\r\n        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\r\n        if ('undefined' !== typeof parsleyMultipleInstance) {\r\n\r\n          if (!this.$element.data('FieldMultiple')) {\r\n            parsleyMultipleInstance.addElement(this.$element);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`\r\n      // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance\r\n      this.bind('parsleyField', true);\r\n\r\n      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\r\n    },\r\n\r\n    // Return proper `Form`, `Field` or `FieldMultiple`\r\n    bind: function (type, doNotStore) {\r\n      var parsleyInstance;\r\n\r\n      switch (type) {\r\n        case 'parsleyForm':\r\n          parsleyInstance = $.extend(\r\n            new Form(this.element, this.domOptions, this.options),\r\n            new Base(),\r\n            window.ParsleyExtend\r\n          )._bindFields();\r\n          break;\r\n        case 'parsleyField':\r\n          parsleyInstance = $.extend(\r\n            new parsley_field(this.element, this.domOptions, this.options, this.parent),\r\n            new Base(),\r\n            window.ParsleyExtend\r\n          );\r\n          break;\r\n        case 'parsleyFieldMultiple':\r\n          parsleyInstance = $.extend(\r\n            new parsley_field(this.element, this.domOptions, this.options, this.parent),\r\n            new Multiple(),\r\n            new Base(),\r\n            window.ParsleyExtend\r\n          )._init();\r\n          break;\r\n        default:\r\n          throw new Error(type + 'is not a supported Parsley type');\r\n      }\r\n\r\n      if (this.options.multiple)\r\n        Utils.setAttr(this.element, this.options.namespace, 'multiple', this.options.multiple);\r\n\r\n      if ('undefined' !== typeof doNotStore) {\r\n        this.$element.data('FieldMultiple', parsleyInstance);\r\n\r\n        return parsleyInstance;\r\n      }\r\n\r\n      // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\r\n      this.$element.data('Parsley', parsleyInstance);\r\n\r\n      // Tell the world we have a new Form or Field instance!\r\n      parsleyInstance._actualizeTriggers();\r\n      parsleyInstance._trigger('init');\r\n\r\n      return parsleyInstance;\r\n    }\r\n  };\n\n  var vernums = $.fn.jquery.split('.');\r\n  if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\r\n    throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\r\n  }\r\n  if (!vernums.forEach) {\r\n    Utils.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\r\n  }\r\n  // Inherit `on`, `off` & `trigger` to Parsley:\r\n  var Parsley = Object.assign(new Base(), {\r\n      element: document,\r\n      $element: $(document),\r\n      actualizeOptions: null,\r\n      _resetOptions: null,\r\n      Factory: Factory,\r\n      version: '2.7.3'\r\n    });\r\n\r\n  // Supplement Field and Form with Base\r\n  // This way, the constructors will have access to those methods\r\n  Object.assign(parsley_field.prototype, UI.Field, Base.prototype);\r\n  Object.assign(Form.prototype, UI.Form, Base.prototype);\r\n  // Inherit actualizeOptions and _resetOptions:\r\n  Object.assign(Factory.prototype, Base.prototype);\r\n\r\n  // ### jQuery API\r\n  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`\r\n  $.fn.parsley = $.fn.psly = function (options) {\r\n    if (this.length > 1) {\r\n      var instances = [];\r\n\r\n      this.each(function () {\r\n        instances.push($(this).parsley(options));\r\n      });\r\n\r\n      return instances;\r\n    }\r\n\r\n    // Return undefined if applied to non existing DOM element\r\n    if (!$(this).length) {\r\n      Utils.warn('You must bind Parsley on an existing element.');\r\n\r\n      return;\r\n    }\r\n\r\n    return new Factory(this[0], options);\r\n  };\r\n\r\n  // ### Field and Form extension\r\n  // Ensure the extension is now defined if it wasn't previously\r\n  if ('undefined' === typeof window.ParsleyExtend)\r\n    window.ParsleyExtend = {};\r\n\r\n  // ### Parsley config\r\n  // Inherit from ParsleyDefault, and copy over any existing values\r\n  Parsley.options = Object.assign(Utils.objectCreate(Defaults), window.ParsleyConfig);\r\n  window.ParsleyConfig = Parsley.options; // Old way of accessing global options\r\n\r\n  // ### Globals\r\n  window.Parsley = window.psly = Parsley;\r\n  Parsley.Utils = Utils;\r\n  window.ParsleyUtils = {};\r\n  $.each(Utils, (key, value) => {\r\n    if ('function' === typeof value) {\r\n      window.ParsleyUtils[key] = (...args) => {\r\n        Utils.warnOnce('Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.');\r\n        return Utils[key](...args);\r\n      };\r\n    }\r\n  });\r\n\r\n  // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\r\n  var registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\r\n  window.ParsleyValidator = {};\r\n  $.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\r\n    window.Parsley[method] = (...args) => registry[method](...args);\r\n    window.ParsleyValidator[method] = function () {\r\n      Utils.warnOnce(`Accessing the method '${method}' through Validator is deprecated. Simply call 'window.Parsley.${method}(...)'`);\r\n      return window.Parsley[method](...arguments);\r\n    };\r\n  });\r\n\r\n  // ### UI\r\n  // Deprecated global object\r\n  window.Parsley.UI = UI;\r\n  window.ParsleyUI = {\r\n    removeError: function (instance, name, doNotUpdateClass) {\r\n      var updateClass = true !== doNotUpdateClass;\r\n      Utils.warnOnce(`Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\r\n      return instance.removeError(name, {updateClass});\r\n    },\r\n    getErrorsMessages: function (instance) {\r\n      Utils.warnOnce(`Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly.`);\r\n      return instance.getErrorsMessages();\r\n    }\r\n  };\r\n  $.each('addError updateError'.split(' '), function (i, method) {\r\n    window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\r\n      var updateClass = true !== doNotUpdateClass;\r\n      Utils.warnOnce(`Accessing UI is deprecated. Call '${method}' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\r\n      return instance[method](name, {message, assert, updateClass});\r\n    };\r\n  });\r\n\r\n  // ### PARSLEY auto-binding\r\n  // Prevent it by setting `ParsleyConfig.autoBind` to `false`\r\n  if (false !== window.ParsleyConfig.autoBind) {\r\n    $(function () {\r\n      // Works only on `data-parsley-validate`.\r\n      if ($('[data-parsley-validate]').length)\r\n        $('[data-parsley-validate]').parsley();\r\n    });\r\n  }\n\n  var o = $({});\r\n  var deprecated = function () {\r\n    Utils.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\r\n  };\r\n\r\n  // Returns an event handler that calls `fn` with the arguments it expects\r\n  function adapt(fn, context) {\r\n    // Store to allow unbinding\r\n    if (!fn.parsleyAdaptedCallback) {\r\n      fn.parsleyAdaptedCallback = function () {\r\n        var args = Array.prototype.slice.call(arguments, 0);\r\n        args.unshift(this);\r\n        fn.apply(context || o, args);\r\n      };\r\n    }\r\n    return fn.parsleyAdaptedCallback;\r\n  }\r\n\r\n  var eventPrefix = 'parsley:';\r\n  // Converts 'parsley:form:validate' into 'form:validate'\r\n  function eventName(name) {\r\n    if (name.lastIndexOf(eventPrefix, 0) === 0)\r\n      return name.substr(eventPrefix.length);\r\n    return name;\r\n  }\r\n\r\n  // $.listen is deprecated. Use Parsley.on instead.\r\n  $.listen = function (name, callback) {\r\n    var context;\r\n    deprecated();\r\n    if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\r\n      context = arguments[1];\r\n      callback = arguments[2];\r\n    }\r\n\r\n    if ('function' !== typeof callback)\r\n      throw new Error('Wrong parameters');\r\n\r\n    window.Parsley.on(eventName(name), adapt(callback, context));\r\n  };\r\n\r\n  $.listenTo = function (instance, name, fn) {\r\n    deprecated();\r\n    if (!(instance instanceof parsley_field) && !(instance instanceof Form))\r\n      throw new Error('Must give Parsley instance');\r\n\r\n    if ('string' !== typeof name || 'function' !== typeof fn)\r\n      throw new Error('Wrong parameters');\r\n\r\n    instance.on(eventName(name), adapt(fn));\r\n  };\r\n\r\n  $.unsubscribe = function (name, fn) {\r\n    deprecated();\r\n    if ('string' !== typeof name || 'function' !== typeof fn)\r\n      throw new Error('Wrong arguments');\r\n    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\r\n  };\r\n\r\n  $.unsubscribeTo = function (instance, name) {\r\n    deprecated();\r\n    if (!(instance instanceof parsley_field) && !(instance instanceof Form))\r\n      throw new Error('Must give Parsley instance');\r\n    instance.off(eventName(name));\r\n  };\r\n\r\n  $.unsubscribeAll = function (name) {\r\n    deprecated();\r\n    window.Parsley.off(eventName(name));\r\n    $('form,input,textarea,select').each(function () {\r\n      var instance = $(this).data('Parsley');\r\n      if (instance) {\r\n        instance.off(eventName(name));\r\n      }\r\n    });\r\n  };\r\n\r\n  // $.emit is deprecated. Use jQuery events instead.\r\n  $.emit = function (name, instance) {\r\n    deprecated();\r\n    var instanceGiven = (instance instanceof parsley_field) || (instance instanceof Form);\r\n    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\r\n    args.unshift(eventName(name));\r\n    if (!instanceGiven) {\r\n      instance = window.Parsley;\r\n    }\r\n    instance.trigger(...args);\r\n  };\r\n\r\n  var pubsub = {};\n\n  $.extend(true, Parsley, {\r\n    asyncValidators: {\r\n      'default': {\r\n        fn: function (xhr) {\r\n          // By default, only status 2xx are deemed successful.\r\n          // Note: we use status instead of state() because responses with status 200\r\n          // but invalid messages (e.g. an empty body for content type set to JSON) will\r\n          // result in state() === 'rejected'.\r\n          return xhr.status >= 200 && xhr.status < 300;\r\n        },\r\n        url: false\r\n      },\r\n      reverse: {\r\n        fn: function (xhr) {\r\n          // If reverse option is set, a failing ajax request is considered successful\r\n          return xhr.status < 200 || xhr.status >= 300;\r\n        },\r\n        url: false\r\n      }\r\n    },\r\n\r\n    addAsyncValidator: function (name, fn, url, options) {\r\n      Parsley.asyncValidators[name] = {\r\n        fn: fn,\r\n        url: url || false,\r\n        options: options || {}\r\n      };\r\n\r\n      return this;\r\n    }\r\n\r\n  });\r\n\r\n  Parsley.addValidator('remote', {\r\n    requirementType: {\r\n      '': 'string',\r\n      'validator': 'string',\r\n      'reverse': 'boolean',\r\n      'options': 'object'\r\n    },\r\n\r\n    validateString: function (value, url, options, instance) {\r\n      var data = {};\r\n      var ajaxOptions;\r\n      var csr;\r\n      var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\r\n\r\n      if ('undefined' === typeof Parsley.asyncValidators[validator])\r\n        throw new Error('Calling an undefined async validator: `' + validator + '`');\r\n\r\n      url = Parsley.asyncValidators[validator].url || url;\r\n\r\n      // Fill current value\r\n      if (url.indexOf('{value}') > -1) {\r\n        url = url.replace('{value}', encodeURIComponent(value));\r\n      } else {\r\n        data[instance.element.getAttribute('name') || instance.element.getAttribute('id')] = value;\r\n      }\r\n\r\n      // Merge options passed in from the function with the ones in the attribute\r\n      var remoteOptions = $.extend(true, options.options || {} , Parsley.asyncValidators[validator].options);\r\n\r\n      // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\r\n      ajaxOptions = $.extend(true, {}, {\r\n        url: url,\r\n        data: data,\r\n        type: 'GET'\r\n      }, remoteOptions);\r\n\r\n      // Generate store key based on ajax options\r\n      instance.trigger('field:ajaxoptions', instance, ajaxOptions);\r\n\r\n      csr = $.param(ajaxOptions);\r\n\r\n      // Initialise querry cache\r\n      if ('undefined' === typeof Parsley._remoteCache)\r\n        Parsley._remoteCache = {};\r\n\r\n      // Try to retrieve stored xhr\r\n      var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\r\n\r\n      var handleXhr = function () {\r\n        var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\r\n        if (!result) // Map falsy results to rejected promise\r\n          result = $.Deferred().reject();\r\n        return $.when(result);\r\n      };\r\n\r\n      return xhr.then(handleXhr, handleXhr);\r\n    },\r\n\r\n    priority: -1\r\n  });\r\n\r\n  Parsley.on('form:submit', function () {\r\n    Parsley._remoteCache = {};\r\n  });\r\n\r\n  Base.prototype.addAsyncValidator = function () {\r\n    Utils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\r\n    return Parsley.addAsyncValidator(...arguments);\r\n  };\n\n  // This is included with the Parsley library itself,\r\n  // thus there is no use in adding it to your project.\r\n  Parsley.addMessages('en', {\r\n    defaultMessage: \"This value seems to be invalid.\",\r\n    type: {\r\n      email:        \"This value should be a valid email.\",\r\n      url:          \"This value should be a valid url.\",\r\n      number:       \"This value should be a valid number.\",\r\n      integer:      \"This value should be a valid integer.\",\r\n      digits:       \"This value should be digits.\",\r\n      alphanum:     \"This value should be alphanumeric.\"\r\n    },\r\n    notblank:       \"This value should not be blank.\",\r\n    required:       \"This value is required.\",\r\n    pattern:        \"This value seems to be invalid.\",\r\n    min:            \"This value should be greater than or equal to %s.\",\r\n    max:            \"This value should be lower than or equal to %s.\",\r\n    range:          \"This value should be between %s and %s.\",\r\n    minlength:      \"This value is too short. It should have %s characters or more.\",\r\n    maxlength:      \"This value is too long. It should have %s characters or fewer.\",\r\n    length:         \"This value length is invalid. It should be between %s and %s characters long.\",\r\n    mincheck:       \"You must select at least %s choices.\",\r\n    maxcheck:       \"You must select %s choices or fewer.\",\r\n    check:          \"You must select between %s and %s choices.\",\r\n    equalto:        \"This value should be the same.\"\r\n  });\r\n\r\n  Parsley.setLocale('en');\n\n  /**\r\n   * inputevent - Alleviate browser bugs for input events\r\n   * https://github.com/marcandre/inputevent\r\n   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)\r\n   * @author Marc-Andre Lafortune <github@marc-andre.ca>\r\n   * @license MIT\r\n   */\r\n\r\n  function InputEvent() {\r\n    let globals = window || global;\r\n\r\n    // Slightly odd way construct our object. This way methods are force bound.\r\n    // Used to test for duplicate library.\r\n    Object.assign(this, {\r\n\r\n      // For browsers that do not support isTrusted, assumes event is native.\r\n      isNativeEvent: evt => {\r\n        return evt.originalEvent && evt.originalEvent.isTrusted !== false;\r\n      },\r\n\r\n      fakeInputEvent: evt => {\r\n        if (this.isNativeEvent(evt)) {\r\n          $(evt.target).trigger('input');\r\n        }\r\n      },\r\n\r\n      misbehaves: evt => {\r\n        if (this.isNativeEvent(evt)) {\r\n          this.behavesOk(evt);\r\n          $(document)\r\n            .on('change.inputevent', evt.data.selector, this.fakeInputEvent);\r\n          this.fakeInputEvent(evt);\r\n        }\r\n      },\r\n\r\n      behavesOk: evt => {\r\n        if (this.isNativeEvent(evt)) {\r\n          $(document) // Simply unbinds the testing handler\r\n            .off('input.inputevent', evt.data.selector, this.behavesOk)\r\n            .off('change.inputevent', evt.data.selector, this.misbehaves);\r\n        }\r\n      },\r\n\r\n      // Bind the testing handlers\r\n      install: () => {\r\n        if (globals.inputEventPatched) {\r\n          return;\r\n        }\r\n        globals.inputEventPatched = '0.0.3';\r\n        for (let selector of ['select', 'input[type=\"checkbox\"]', 'input[type=\"radio\"]', 'input[type=\"file\"]']) {\r\n          $(document)\r\n            .on('input.inputevent', selector, {selector}, this.behavesOk)\r\n            .on('change.inputevent', selector, {selector}, this.misbehaves);\r\n        }\r\n      },\r\n\r\n      uninstall: () => {\r\n        delete globals.inputEventPatched;\r\n        $(document).off('.inputevent');\r\n      }\r\n\r\n    });\r\n  };\r\n\r\n  var inputevent = new InputEvent();\n\n  inputevent.install();\r\n\r\n  var parsley = Parsley;\n\n  return parsley;\n\n}));\n","import $ from 'jquery';\r\nimport Field from './field';\r\nimport Form from './form';\r\nimport Utils from './utils';\r\n\r\nvar o = $({});\r\nvar deprecated = function () {\r\n  Utils.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\r\n};\r\n\r\n// Returns an event handler that calls `fn` with the arguments it expects\r\nfunction adapt(fn, context) {\r\n  // Store to allow unbinding\r\n  if (!fn.parsleyAdaptedCallback) {\r\n    fn.parsleyAdaptedCallback = function () {\r\n      var args = Array.prototype.slice.call(arguments, 0);\r\n      args.unshift(this);\r\n      fn.apply(context || o, args);\r\n    };\r\n  }\r\n  return fn.parsleyAdaptedCallback;\r\n}\r\n\r\nvar eventPrefix = 'parsley:';\r\n// Converts 'parsley:form:validate' into 'form:validate'\r\nfunction eventName(name) {\r\n  if (name.lastIndexOf(eventPrefix, 0) === 0)\r\n    return name.substr(eventPrefix.length);\r\n  return name;\r\n}\r\n\r\n// $.listen is deprecated. Use Parsley.on instead.\r\n$.listen = function (name, callback) {\r\n  var context;\r\n  deprecated();\r\n  if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\r\n    context = arguments[1];\r\n    callback = arguments[2];\r\n  }\r\n\r\n  if ('function' !== typeof callback)\r\n    throw new Error('Wrong parameters');\r\n\r\n  window.Parsley.on(eventName(name), adapt(callback, context));\r\n};\r\n\r\n$.listenTo = function (instance, name, fn) {\r\n  deprecated();\r\n  if (!(instance instanceof Field) && !(instance instanceof Form))\r\n    throw new Error('Must give Parsley instance');\r\n\r\n  if ('string' !== typeof name || 'function' !== typeof fn)\r\n    throw new Error('Wrong parameters');\r\n\r\n  instance.on(eventName(name), adapt(fn));\r\n};\r\n\r\n$.unsubscribe = function (name, fn) {\r\n  deprecated();\r\n  if ('string' !== typeof name || 'function' !== typeof fn)\r\n    throw new Error('Wrong arguments');\r\n  window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\r\n};\r\n\r\n$.unsubscribeTo = function (instance, name) {\r\n  deprecated();\r\n  if (!(instance instanceof Field) && !(instance instanceof Form))\r\n    throw new Error('Must give Parsley instance');\r\n  instance.off(eventName(name));\r\n};\r\n\r\n$.unsubscribeAll = function (name) {\r\n  deprecated();\r\n  window.Parsley.off(eventName(name));\r\n  $('form,input,textarea,select').each(function () {\r\n    var instance = $(this).data('Parsley');\r\n    if (instance) {\r\n      instance.off(eventName(name));\r\n    }\r\n  });\r\n};\r\n\r\n// $.emit is deprecated. Use jQuery events instead.\r\n$.emit = function (name, instance) {\r\n  deprecated();\r\n  var instanceGiven = (instance instanceof Field) || (instance instanceof Form);\r\n  var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\r\n  args.unshift(eventName(name));\r\n  if (!instanceGiven) {\r\n    instance = window.Parsley;\r\n  }\r\n  instance.trigger(...args);\r\n};\r\n\r\nexport default {};\r\n","/**\r\n * inputevent - Alleviate browser bugs for input events\r\n * https://github.com/marcandre/inputevent\r\n * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)\r\n * @author Marc-Andre Lafortune <github@marc-andre.ca>\r\n * @license MIT\r\n */\r\n\r\nimport $ from 'jquery';\r\n\r\nfunction InputEvent() {\r\n  let globals = window || global;\r\n\r\n  // Slightly odd way construct our object. This way methods are force bound.\r\n  // Used to test for duplicate library.\r\n  Object.assign(this, {\r\n\r\n    // For browsers that do not support isTrusted, assumes event is native.\r\n    isNativeEvent: evt => {\r\n      return evt.originalEvent && evt.originalEvent.isTrusted !== false;\r\n    },\r\n\r\n    fakeInputEvent: evt => {\r\n      if (this.isNativeEvent(evt)) {\r\n        $(evt.target).trigger('input');\r\n      }\r\n    },\r\n\r\n    misbehaves: evt => {\r\n      if (this.isNativeEvent(evt)) {\r\n        this.behavesOk(evt);\r\n        $(document)\r\n          .on('change.inputevent', evt.data.selector, this.fakeInputEvent);\r\n        this.fakeInputEvent(evt);\r\n      }\r\n    },\r\n\r\n    behavesOk: evt => {\r\n      if (this.isNativeEvent(evt)) {\r\n        $(document) // Simply unbinds the testing handler\r\n          .off('input.inputevent', evt.data.selector, this.behavesOk)\r\n          .off('change.inputevent', evt.data.selector, this.misbehaves);\r\n      }\r\n    },\r\n\r\n    // Bind the testing handlers\r\n    install: () => {\r\n      if (globals.inputEventPatched) {\r\n        return;\r\n      }\r\n      globals.inputEventPatched = '0.0.3';\r\n      for (let selector of ['select', 'input[type=\"checkbox\"]', 'input[type=\"radio\"]', 'input[type=\"file\"]']) {\r\n        $(document)\r\n          .on('input.inputevent', selector, {selector}, this.behavesOk)\r\n          .on('change.inputevent', selector, {selector}, this.misbehaves);\r\n      }\r\n    },\r\n\r\n    uninstall: () => {\r\n      delete globals.inputEventPatched;\r\n      $(document).off('.inputevent');\r\n    }\r\n\r\n  });\r\n};\r\n\r\nexport default new InputEvent();\r\n","import $ from 'jquery';\r\n\r\nvar globalID = 1;\r\nvar pastWarnings = {};\r\n\r\nvar Utils = {\r\n  // Parsley DOM-API\r\n  // returns object from dom attributes and values\r\n  attr: function (element, namespace, obj) {\r\n    var i;\r\n    var attribute;\r\n    var attributes;\r\n    var regex = new RegExp('^' + namespace, 'i');\r\n\r\n    if ('undefined' === typeof obj)\r\n      obj = {};\r\n    else {\r\n      // Clear all own properties. This won't affect prototype's values\r\n      for (i in obj) {\r\n        if (obj.hasOwnProperty(i))\r\n          delete obj[i];\r\n      }\r\n    }\r\n\r\n    if (!element)\r\n      return obj;\r\n\r\n    attributes = element.attributes;\r\n    for (i = attributes.length; i--; ) {\r\n      attribute = attributes[i];\r\n\r\n      if (attribute && attribute.specified && regex.test(attribute.name)) {\r\n        obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\r\n      }\r\n    }\r\n\r\n    return obj;\r\n  },\r\n\r\n  checkAttr: function (element, namespace, checkAttr) {\r\n    return element.hasAttribute(namespace + checkAttr);\r\n  },\r\n\r\n  setAttr: function (element, namespace, attr, value) {\r\n    element.setAttribute(this.dasherize(namespace + attr), String(value));\r\n  },\r\n\r\n  generateID: function () {\r\n    return '' + globalID++;\r\n  },\r\n\r\n  /** Third party functions **/\r\n  // Zepto deserialize function\r\n  deserializeValue: function (value) {\r\n    var num;\r\n\r\n    try {\r\n      return value ?\r\n        value == \"true\" ||\r\n        (value == \"false\" ? false :\r\n        value == \"null\" ? null :\r\n        !isNaN(num = Number(value)) ? num :\r\n        /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\r\n        value)\r\n        : value;\r\n    } catch (e) { return value; }\r\n  },\r\n\r\n  // Zepto camelize function\r\n  camelize: function (str) {\r\n    return str.replace(/-+(.)?/g, function (match, chr) {\r\n      return chr ? chr.toUpperCase() : '';\r\n    });\r\n  },\r\n\r\n  // Zepto dasherize function\r\n  dasherize: function (str) {\r\n    return str.replace(/::/g, '/')\r\n      .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\r\n      .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\r\n      .replace(/_/g, '-')\r\n      .toLowerCase();\r\n  },\r\n\r\n  warn: function () {\r\n    if (window.console && 'function' === typeof window.console.warn)\r\n      window.console.warn(...arguments);\r\n  },\r\n\r\n  warnOnce: function(msg) {\r\n    if (!pastWarnings[msg]) {\r\n      pastWarnings[msg] = true;\r\n      this.warn(...arguments);\r\n    }\r\n  },\r\n\r\n  _resetWarnings: function () {\r\n    pastWarnings = {};\r\n  },\r\n\r\n  trimString: function(string) {\r\n    return string.replace(/^\\s+|\\s+$/g, '');\r\n  },\r\n\r\n  parse: {\r\n    date: function(string) {\r\n      let parsed = string.match(/^(\\d{4,})-(\\d\\d)-(\\d\\d)$/);\r\n      if (!parsed)\r\n        return null;\r\n      let [_, year, month, day] = parsed.map(x => parseInt(x, 10));\r\n      let date = new Date(year, month - 1, day);\r\n      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day)\r\n        return null;\r\n      return date;\r\n    },\r\n    string: function(string) {\r\n      return string;\r\n    },\r\n    integer: function(string) {\r\n      if (isNaN(string))\r\n        return null;\r\n      return parseInt(string, 10);\r\n    },\r\n    number: function(string) {\r\n      if (isNaN(string))\r\n        throw null;\r\n      return parseFloat(string);\r\n    },\r\n    'boolean': function _boolean(string) {\r\n      return !(/^\\s*false\\s*$/i.test(string));\r\n    },\r\n    object: function(string) {\r\n      return Utils.deserializeValue(string);\r\n    },\r\n    regexp: function(regexp) {\r\n      var flags = '';\r\n\r\n      // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\r\n      if (/^\\/.*\\/(?:[gimy]*)$/.test(regexp)) {\r\n        // Replace the regexp literal string with the first match group: ([gimy]*)\r\n        // If no flag is present, this will be a blank string\r\n        flags = regexp.replace(/.*\\/([gimy]*)$/, '$1');\r\n        // Again, replace the regexp literal string with the first match group:\r\n        // everything excluding the opening and closing slashes and the flags\r\n        regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\r\n      } else {\r\n        // Anchor regexp:\r\n        regexp = '^' + regexp + '$';\r\n      }\r\n      return new RegExp(regexp, flags);\r\n    }\r\n  },\r\n\r\n  parseRequirement: function(requirementType, string) {\r\n    var converter = this.parse[requirementType || 'string'];\r\n    if (!converter)\r\n      throw 'Unknown requirement specification: \"' + requirementType + '\"';\r\n    let converted = converter(string);\r\n    if (converted === null)\r\n      throw `Requirement is not a ${requirementType}: \"${string}\"`;\r\n    return converted;\r\n  },\r\n\r\n  namespaceEvents: function(events, namespace) {\r\n    events = this.trimString(events || '').split(/\\s+/);\r\n    if (!events[0])\r\n      return '';\r\n    return $.map(events, evt => `${evt}.${namespace}`).join(' ');\r\n  },\r\n\r\n  difference: function(array, remove) {\r\n    // This is O(N^2), should be optimized\r\n    let result = [];\r\n    $.each(array, (_, elem) => {\r\n      if (remove.indexOf(elem) == -1)\r\n        result.push(elem);\r\n    });\r\n    return result;\r\n  },\r\n\r\n  // Alter-ego to native Promise.all, but for jQuery\r\n  all: function(promises) {\r\n    // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\r\n    return $.when(...promises, 42, 42);\r\n  },\r\n\r\n  // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\r\n  objectCreate: Object.create || (function () {\r\n    var Object = function () {};\r\n    return function (prototype) {\r\n      if (arguments.length > 1) {\r\n        throw Error('Second argument not supported');\r\n      }\r\n      if (typeof prototype != 'object') {\r\n        throw TypeError('Argument must be an object');\r\n      }\r\n      Object.prototype = prototype;\r\n      var result = new Object();\r\n      Object.prototype = null;\r\n      return result;\r\n    };\r\n  })(),\r\n\r\n  _SubmitSelector: 'input[type=\"submit\"], button:submit'\r\n};\r\n\r\nexport default Utils;\r\n","// All these options could be overriden and specified directly in DOM using\r\n// `data-parsley-` default DOM-API\r\n// eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\r\n// eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\r\n\r\nvar Defaults = {\r\n  // ### General\r\n\r\n  // Default data-namespace for DOM API\r\n  namespace: 'data-parsley-',\r\n\r\n  // Supported inputs by default\r\n  inputs: 'input, textarea, select',\r\n\r\n  // Excluded inputs by default\r\n  excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\r\n\r\n  // Stop validating field on highest priority failing constraint\r\n  priorityEnabled: true,\r\n\r\n  // ### Field only\r\n\r\n  // identifier used to group together inputs (e.g. radio buttons...)\r\n  multiple: null,\r\n\r\n  // identifier (or array of identifiers) used to validate only a select group of inputs\r\n  group: null,\r\n\r\n  // ### UI\r\n  // Enable\\Disable error messages\r\n  uiEnabled: true,\r\n\r\n  // Key events threshold before validation\r\n  validationThreshold: 3,\r\n\r\n  // Focused field on form validation error. 'first'|'last'|'none'\r\n  focus: 'first',\r\n\r\n  // event(s) that will trigger validation before first failure. eg: `input`...\r\n  trigger: false,\r\n\r\n  // event(s) that will trigger validation after first failure.\r\n  triggerAfterFailure: 'input',\r\n\r\n  // Class that would be added on every failing validation Parsley field\r\n  errorClass: 'parsley-error',\r\n\r\n  // Same for success validation\r\n  successClass: 'parsley-success',\r\n\r\n  // Return the `$element` that will receive these above success or error classes\r\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\r\n  classHandler: function (Field) {},\r\n\r\n  // Return the `$element` where errors will be appended\r\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\r\n  errorsContainer: function (Field) {},\r\n\r\n  // ul elem that would receive errors' list\r\n  errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\r\n\r\n  // li elem that would receive error message\r\n  errorTemplate: '<li></li>'\r\n};\r\n\r\nexport default Defaults;\r\n","import $ from 'jquery';\r\nimport Utils from './utils';\r\n\r\nvar Base = function () {\r\n  this.__id__ = Utils.generateID();\r\n};\r\n\r\nBase.prototype = {\r\n  asyncSupport: true, // Deprecated\r\n\r\n  _pipeAccordingToValidationResult: function () {\r\n    var pipe = () => {\r\n      var r = $.Deferred();\r\n      if (true !== this.validationResult)\r\n        r.reject();\r\n      return r.resolve().promise();\r\n    };\r\n    return [pipe, pipe];\r\n  },\r\n\r\n  actualizeOptions: function () {\r\n    Utils.attr(this.element, this.options.namespace, this.domOptions);\r\n    if (this.parent && this.parent.actualizeOptions)\r\n      this.parent.actualizeOptions();\r\n    return this;\r\n  },\r\n\r\n  _resetOptions: function (initOptions) {\r\n    this.domOptions = Utils.objectCreate(this.parent.options);\r\n    this.options = Utils.objectCreate(this.domOptions);\r\n    // Shallow copy of ownProperties of initOptions:\r\n    for (var i in initOptions) {\r\n      if (initOptions.hasOwnProperty(i))\r\n        this.options[i] = initOptions[i];\r\n    }\r\n    this.actualizeOptions();\r\n  },\r\n\r\n  _listeners: null,\r\n\r\n  // Register a callback for the given event name\r\n  // Callback is called with context as the first argument and the `this`\r\n  // The context is the current parsley instance, or window.Parsley if global\r\n  // A return value of `false` will interrupt the calls\r\n  on: function (name, fn) {\r\n    this._listeners = this._listeners || {};\r\n    var queue = this._listeners[name] = this._listeners[name] || [];\r\n    queue.push(fn);\r\n\r\n    return this;\r\n  },\r\n\r\n  // Deprecated. Use `on` instead\r\n  subscribe: function(name, fn) {\r\n    $.listenTo(this, name.toLowerCase(), fn);\r\n  },\r\n\r\n  // Unregister a callback (or all if none is given) for the given event name\r\n  off: function (name, fn) {\r\n    var queue = this._listeners && this._listeners[name];\r\n    if (queue) {\r\n      if (!fn) {\r\n        delete this._listeners[name];\r\n      } else {\r\n        for (var i = queue.length; i--; )\r\n          if (queue[i] === fn)\r\n            queue.splice(i, 1);\r\n      }\r\n    }\r\n    return this;\r\n  },\r\n\r\n  // Deprecated. Use `off`\r\n  unsubscribe: function(name, fn) {\r\n    $.unsubscribeTo(this, name.toLowerCase());\r\n  },\r\n\r\n  // Trigger an event of the given name\r\n  // A return value of `false` interrupts the callback chain\r\n  // Returns false if execution was interrupted\r\n  trigger: function (name, target, extraArg) {\r\n    target = target || this;\r\n    var queue = this._listeners && this._listeners[name];\r\n    var result;\r\n    var parentResult;\r\n    if (queue) {\r\n      for (var i = queue.length; i--; ) {\r\n        result = queue[i].call(target, target, extraArg);\r\n        if (result === false) return result;\r\n      }\r\n    }\r\n    if (this.parent) {\r\n      return this.parent.trigger(name, target, extraArg);\r\n    }\r\n    return true;\r\n  },\r\n\r\n  asyncIsValid: function (group, force) {\r\n    Utils.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\r\n    return this.whenValid({group, force});\r\n  },\r\n\r\n  _findRelated: function () {\r\n    return this.options.multiple ?\r\n      $(this.parent.element.querySelectorAll(`[${this.options.namespace}multiple=\"${this.options.multiple}\"]`))\r\n    : this.$element;\r\n  }\r\n};\r\n\r\nexport default Base;\r\n","import $ from 'jquery';\r\nimport Utils from './utils';\r\n\r\nvar convertArrayRequirement = function(string, length) {\r\n  var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\r\n  if (!m)\r\n    throw 'Requirement is not an array: \"' + string + '\"';\r\n  var values = m[1].split(',').map(Utils.trimString);\r\n  if (values.length !== length)\r\n    throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\r\n  return values;\r\n};\r\n\r\nvar convertExtraOptionRequirement = function(requirementSpec, string, extraOptionReader) {\r\n  var main = null;\r\n  var extra = {};\r\n  for (var key in requirementSpec) {\r\n    if (key) {\r\n      var value = extraOptionReader(key);\r\n      if ('string' === typeof value)\r\n        value = Utils.parseRequirement(requirementSpec[key], value);\r\n      extra[key] = value;\r\n    } else {\r\n      main = Utils.parseRequirement(requirementSpec[key], string);\r\n    }\r\n  }\r\n  return [main, extra];\r\n};\r\n\r\n// A Validator needs to implement the methods `validate` and `parseRequirements`\r\n\r\nvar Validator = function(spec) {\r\n  $.extend(true, this, spec);\r\n};\r\n\r\nValidator.prototype = {\r\n  // Returns `true` iff the given `value` is valid according the given requirements.\r\n  validate: function(value, requirementFirstArg) {\r\n    if (this.fn) { // Legacy style validator\r\n\r\n      if (arguments.length > 3)  // If more args then value, requirement, instance...\r\n        requirementFirstArg = [].slice.call(arguments, 1, -1);  // Skip first arg (value) and last (instance), combining the rest\r\n      return this.fn(value, requirementFirstArg);\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n      if (!this.validateMultiple)\r\n        throw 'Validator `' + this.name + '` does not handle multiple values';\r\n      return this.validateMultiple(...arguments);\r\n    } else {\r\n      let instance = arguments[arguments.length - 1];\r\n      if (this.validateDate && instance._isDateInput()) {\r\n        arguments[0] = Utils.parse.date(arguments[0]);\r\n        if (arguments[0] === null)\r\n          return false;\r\n        return this.validateDate(...arguments);\r\n      }\r\n      if (this.validateNumber) {\r\n        if (isNaN(value))\r\n          return false;\r\n        arguments[0] = parseFloat(arguments[0]);\r\n        return this.validateNumber(...arguments);\r\n      }\r\n      if (this.validateString) {\r\n        return this.validateString(...arguments);\r\n      }\r\n      throw 'Validator `' + this.name + '` only handles multiple values';\r\n    }\r\n  },\r\n\r\n  // Parses `requirements` into an array of arguments,\r\n  // according to `this.requirementType`\r\n  parseRequirements: function(requirements, extraOptionReader) {\r\n    if ('string' !== typeof requirements) {\r\n      // Assume requirement already parsed\r\n      // but make sure we return an array\r\n      return Array.isArray(requirements) ? requirements : [requirements];\r\n    }\r\n    var type = this.requirementType;\r\n    if (Array.isArray(type)) {\r\n      var values = convertArrayRequirement(requirements, type.length);\r\n      for (var i = 0; i < values.length; i++)\r\n        values[i] = Utils.parseRequirement(type[i], values[i]);\r\n      return values;\r\n    } else if ($.isPlainObject(type)) {\r\n      return convertExtraOptionRequirement(type, requirements, extraOptionReader);\r\n    } else {\r\n      return [Utils.parseRequirement(type, requirements)];\r\n    }\r\n  },\r\n  // Defaults:\r\n  requirementType: 'string',\r\n\r\n  priority: 2\r\n\r\n};\r\n\r\nexport default Validator;\r\n","import $ from 'jquery';\r\nimport Utils from './utils';\r\nimport Defaults from './defaults';\r\nimport Validator from './validator';\r\n\r\nvar ValidatorRegistry = function (validators, catalog) {\r\n  this.__class__ = 'ValidatorRegistry';\r\n\r\n  // Default Parsley locale is en\r\n  this.locale = 'en';\r\n\r\n  this.init(validators || {}, catalog || {});\r\n};\r\n\r\nvar typeTesters =  {\r\n  email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\r\n\r\n  // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\r\n  number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\r\n\r\n  integer: /^-?\\d+$/,\r\n\r\n  digits: /^\\d+$/,\r\n\r\n  alphanum: /^\\w+$/i,\r\n\r\n  date: {\r\n    test: value => Utils.parse.date(value) !== null\r\n  },\r\n\r\n  url: new RegExp(\r\n      \"^\" +\r\n        // protocol identifier\r\n        \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\r\n        // user:pass authentication\r\n        \"(?:\\\\S+(?::\\\\S*)?@)?\" +\r\n        \"(?:\" +\r\n          // IP address exclusion\r\n          // private & local networks\r\n          // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\r\n          // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\r\n          // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\r\n          // IP address dotted notation octets\r\n          // excludes loopback network 0.0.0.0\r\n          // excludes reserved space >= 224.0.0.0\r\n          // excludes network & broacast addresses\r\n          // (first & last IP address of each class)\r\n          \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\r\n          \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\r\n          \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\r\n        \"|\" +\r\n          // host name\r\n          \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\r\n          // domain name\r\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\r\n          // TLD identifier\r\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\r\n        \")\" +\r\n        // port number\r\n        \"(?::\\\\d{2,5})?\" +\r\n        // resource path\r\n        \"(?:/\\\\S*)?\" +\r\n      \"$\", 'i'\r\n    )\r\n};\r\ntypeTesters.range = typeTesters.number;\r\n\r\n// See http://stackoverflow.com/a/10454560/8279\r\nvar decimalPlaces = num => {\r\n  var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\r\n  if (!match) { return 0; }\r\n  return Math.max(\r\n       0,\r\n       // Number of digits right of decimal point.\r\n       (match[1] ? match[1].length : 0) -\r\n       // Adjust for scientific notation.\r\n       (match[2] ? +match[2] : 0));\r\n};\r\n\r\n// parseArguments('number', ['1', '2']) => [1, 2]\r\nlet parseArguments = (type, args) => args.map(Utils.parse[type]);\r\n// operatorToValidator returns a validating function for an operator function, applied to the given type\r\nlet operatorToValidator = (type, operator) => {\r\n  return (value, ...requirementsAndInput) => {\r\n    requirementsAndInput.pop(); // Get rid of `input` argument\r\n    return operator(value, ...parseArguments(type, requirementsAndInput));\r\n  };\r\n};\r\n\r\nlet comparisonOperator = operator => ({\r\n  validateDate: operatorToValidator('date', operator),\r\n  validateNumber: operatorToValidator('number', operator),\r\n  requirementType: operator.length <= 2 ? 'string' : ['string', 'string'], // Support operators with a 1 or 2 requirement(s)\r\n  priority: 30\r\n});\r\n\r\nValidatorRegistry.prototype = {\r\n  init: function (validators, catalog) {\r\n    this.catalog = catalog;\r\n    // Copy prototype's validators:\r\n    this.validators = Object.assign({}, this.validators);\r\n\r\n    for (var name in validators)\r\n      this.addValidator(name, validators[name].fn, validators[name].priority);\r\n\r\n    window.Parsley.trigger('parsley:validator:init');\r\n  },\r\n\r\n  // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\r\n  setLocale: function (locale) {\r\n    if ('undefined' === typeof this.catalog[locale])\r\n      throw new Error(locale + ' is not available in the catalog');\r\n\r\n    this.locale = locale;\r\n\r\n    return this;\r\n  },\r\n\r\n  // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\r\n  addCatalog: function (locale, messages, set) {\r\n    if ('object' === typeof messages)\r\n      this.catalog[locale] = messages;\r\n\r\n    if (true === set)\r\n      return this.setLocale(locale);\r\n\r\n    return this;\r\n  },\r\n\r\n  // Add a specific message for a given constraint in a given locale\r\n  addMessage: function (locale, name, message) {\r\n    if ('undefined' === typeof this.catalog[locale])\r\n      this.catalog[locale] = {};\r\n\r\n    this.catalog[locale][name] = message;\r\n\r\n    return this;\r\n  },\r\n\r\n  // Add messages for a given locale\r\n  addMessages: function (locale, nameMessageObject) {\r\n    for (var name in nameMessageObject)\r\n      this.addMessage(locale, name, nameMessageObject[name]);\r\n\r\n    return this;\r\n  },\r\n\r\n  // Add a new validator\r\n  //\r\n  //    addValidator('custom', {\r\n  //        requirementType: ['integer', 'integer'],\r\n  //        validateString: function(value, from, to) {},\r\n  //        priority: 22,\r\n  //        messages: {\r\n  //          en: \"Hey, that's no good\",\r\n  //          fr: \"Aye aye, pas bon du tout\",\r\n  //        }\r\n  //    })\r\n  //\r\n  // Old API was addValidator(name, function, priority)\r\n  //\r\n  addValidator: function (name, arg1, arg2) {\r\n    if (this.validators[name])\r\n      Utils.warn('Validator \"' + name + '\" is already defined.');\r\n    else if (Defaults.hasOwnProperty(name)) {\r\n      Utils.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\r\n      return;\r\n    }\r\n    return this._setValidator(...arguments);\r\n  },\r\n\r\n  updateValidator: function (name, arg1, arg2) {\r\n    if (!this.validators[name]) {\r\n      Utils.warn('Validator \"' + name + '\" is not already defined.');\r\n      return this.addValidator(...arguments);\r\n    }\r\n    return this._setValidator(...arguments);\r\n  },\r\n\r\n  removeValidator: function (name) {\r\n    if (!this.validators[name])\r\n      Utils.warn('Validator \"' + name + '\" is not defined.');\r\n\r\n    delete this.validators[name];\r\n\r\n    return this;\r\n  },\r\n\r\n  _setValidator: function (name, validator, priority) {\r\n    if ('object' !== typeof validator) {\r\n      // Old style validator, with `fn` and `priority`\r\n      validator = {\r\n        fn: validator,\r\n        priority: priority\r\n      };\r\n    }\r\n    if (!validator.validate) {\r\n      validator = new Validator(validator);\r\n    }\r\n    this.validators[name] = validator;\r\n\r\n    for (var locale in validator.messages || {})\r\n      this.addMessage(locale, name, validator.messages[locale]);\r\n\r\n    return this;\r\n  },\r\n\r\n  getErrorMessage: function (constraint) {\r\n    var message;\r\n\r\n    // Type constraints are a bit different, we have to match their requirements too to find right error message\r\n    if ('type' === constraint.name) {\r\n      var typeMessages = this.catalog[this.locale][constraint.name] || {};\r\n      message = typeMessages[constraint.requirements];\r\n    } else\r\n      message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\r\n\r\n    return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\r\n  },\r\n\r\n  // Kind of light `sprintf()` implementation\r\n  formatMessage: function (string, parameters) {\r\n    if ('object' === typeof parameters) {\r\n      for (var i in parameters)\r\n        string = this.formatMessage(string, parameters[i]);\r\n\r\n      return string;\r\n    }\r\n\r\n    return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\r\n  },\r\n\r\n  // Here is the Parsley default validators list.\r\n  // A validator is an object with the following key values:\r\n  //  - priority: an integer\r\n  //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\r\n  //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\r\n  // Alternatively, a validator can be a function that returns such an object\r\n  //\r\n  validators: {\r\n    notblank: {\r\n      validateString: function(value) {\r\n        return /\\S/.test(value);\r\n      },\r\n      priority: 2\r\n    },\r\n    required: {\r\n      validateMultiple: function(values) {\r\n        return values.length > 0;\r\n      },\r\n      validateString: function(value) {\r\n        return /\\S/.test(value);\r\n      },\r\n      priority: 512\r\n    },\r\n    type: {\r\n      validateString: function(value, type, {step = 'any', base = 0} = {}) {\r\n        var tester = typeTesters[type];\r\n        if (!tester) {\r\n          throw new Error('validator type `' + type + '` is not supported');\r\n        }\r\n        if (!tester.test(value))\r\n          return false;\r\n        if ('number' === type) {\r\n          if (!/^any$/i.test(step || '')) {\r\n            var nb = Number(value);\r\n            var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\r\n            if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\r\n              return false;\r\n            // Be careful of rounding errors by using integers.\r\n            var toInt = f => Math.round(f * Math.pow(10, decimals));\r\n            if ((toInt(nb) - toInt(base)) % toInt(step) != 0)\r\n              return false;\r\n          }\r\n        }\r\n        return true;\r\n      },\r\n      requirementType: {\r\n        '': 'string',\r\n        step: 'string',\r\n        base: 'number'\r\n      },\r\n      priority: 256\r\n    },\r\n    pattern: {\r\n      validateString: function(value, regexp) {\r\n        return regexp.test(value);\r\n      },\r\n      requirementType: 'regexp',\r\n      priority: 64\r\n    },\r\n    minlength: {\r\n      validateString: function (value, requirement) {\r\n        return value.length >= requirement;\r\n      },\r\n      requirementType: 'integer',\r\n      priority: 30\r\n    },\r\n    maxlength: {\r\n      validateString: function (value, requirement) {\r\n        return value.length <= requirement;\r\n      },\r\n      requirementType: 'integer',\r\n      priority: 30\r\n    },\r\n    length: {\r\n      validateString: function (value, min, max) {\r\n        return value.length >= min && value.length <= max;\r\n      },\r\n      requirementType: ['integer', 'integer'],\r\n      priority: 30\r\n    },\r\n    mincheck: {\r\n      validateMultiple: function (values, requirement) {\r\n        return values.length >= requirement;\r\n      },\r\n      requirementType: 'integer',\r\n      priority: 30\r\n    },\r\n    maxcheck: {\r\n      validateMultiple: function (values, requirement) {\r\n        return values.length <= requirement;\r\n      },\r\n      requirementType: 'integer',\r\n      priority: 30\r\n    },\r\n    check: {\r\n      validateMultiple: function (values, min, max) {\r\n        return values.length >= min && values.length <= max;\r\n      },\r\n      requirementType: ['integer', 'integer'],\r\n      priority: 30\r\n    },\r\n    min: comparisonOperator((value, requirement) => value >= requirement),\r\n    max: comparisonOperator((value, requirement) => value <= requirement),\r\n    range: comparisonOperator((value, min, max) => value >= min && value <= max),\r\n    equalto: {\r\n      validateString: function (value, refOrValue) {\r\n        var $reference = $(refOrValue);\r\n        if ($reference.length)\r\n          return value === $reference.val();\r\n        else\r\n          return value === refOrValue;\r\n      },\r\n      priority: 256\r\n    }\r\n  }\r\n};\r\n\r\nexport default ValidatorRegistry;\r\n","import $ from 'jquery';\r\nimport Utils from './utils';\r\n\r\nvar UI = {};\r\n\r\nvar diffResults = function (newResult, oldResult, deep) {\r\n  var added = [];\r\n  var kept = [];\r\n\r\n  for (var i = 0; i < newResult.length; i++) {\r\n    var found = false;\r\n\r\n    for (var j = 0; j < oldResult.length; j++)\r\n      if (newResult[i].assert.name === oldResult[j].assert.name) {\r\n        found = true;\r\n        break;\r\n      }\r\n\r\n    if (found)\r\n      kept.push(newResult[i]);\r\n    else\r\n      added.push(newResult[i]);\r\n  }\r\n\r\n  return {\r\n    kept: kept,\r\n    added: added,\r\n    removed: !deep ? diffResults(oldResult, newResult, true).added : []\r\n  };\r\n};\r\n\r\nUI.Form = {\r\n\r\n  _actualizeTriggers: function () {\r\n    this.$element.on('submit.Parsley', evt => { this.onSubmitValidate(evt); });\r\n    this.$element.on('click.Parsley', Utils._SubmitSelector, evt => { this.onSubmitButton(evt); });\r\n\r\n    // UI could be disabled\r\n    if (false === this.options.uiEnabled)\r\n      return;\r\n\r\n    this.element.setAttribute('novalidate', '');\r\n  },\r\n\r\n  focus: function () {\r\n    this._focusedField = null;\r\n\r\n    if (true === this.validationResult || 'none' === this.options.focus)\r\n      return null;\r\n\r\n    for (var i = 0; i < this.fields.length; i++) {\r\n      var field = this.fields[i];\r\n      if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\r\n        this._focusedField = field.$element;\r\n        if ('first' === this.options.focus)\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (null === this._focusedField)\r\n      return null;\r\n\r\n    return this._focusedField.focus();\r\n  },\r\n\r\n  _destroyUI: function () {\r\n    // Reset all event listeners\r\n    this.$element.off('.Parsley');\r\n  }\r\n\r\n};\r\n\r\nUI.Field = {\r\n\r\n  _reflowUI: function ({silent} = {}) {\r\n    this._buildUI();\r\n\r\n    // If this field doesn't have an active UI don't bother doing something\r\n    if (!this._ui)\r\n      return;\r\n\r\n    // Diff between two validation results\r\n    var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\r\n\r\n    // Then store current validation result for next reflow\r\n    this._ui.lastValidationResult = this.validationResult;\r\n\r\n    // Handle valid / invalid / none field class\r\n    this._manageStatusClass();\r\n\r\n    // Add, remove, updated errors messages\r\n    if (!silent) this._manageErrorsMessages(diff);\r\n\r\n    // Triggers impl\r\n    this._actualizeTriggers();\r\n\r\n    // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\r\n    if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\r\n      this._failedOnce = true;\r\n      this._actualizeTriggers();\r\n    }\r\n  },\r\n\r\n  // Returns an array of field's error message(s)\r\n  getErrorsMessages: function () {\r\n    // No error message, field is valid\r\n    if (true === this.validationResult)\r\n      return [];\r\n\r\n    var messages = [];\r\n\r\n    for (var i = 0; i < this.validationResult.length; i++)\r\n      messages.push(this.validationResult[i].errorMessage ||\r\n       this._getErrorMessage(this.validationResult[i].assert));\r\n\r\n    return messages;\r\n  },\r\n\r\n  // It's a goal of Parsley that this method is no longer required [#1073]\r\n  addError: function (name, {message, assert, updateClass = true} = {}) {\r\n    this._buildUI();\r\n    this._addError(name, {message, assert});\r\n\r\n    if (updateClass)\r\n      this._errorClass();\r\n  },\r\n\r\n  // It's a goal of Parsley that this method is no longer required [#1073]\r\n  updateError: function (name, {message, assert, updateClass = true} = {}) {\r\n    this._buildUI();\r\n    this._updateError(name, {message, assert});\r\n\r\n    if (updateClass)\r\n      this._errorClass();\r\n  },\r\n\r\n  // It's a goal of Parsley that this method is no longer required [#1073]\r\n  removeError: function (name, {updateClass = true} = {}) {\r\n    this._buildUI();\r\n    this._removeError(name);\r\n\r\n    // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\r\n    // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\r\n    if (updateClass)\r\n      this._manageStatusClass();\r\n  },\r\n\r\n  _manageStatusClass: function () {\r\n    if (this.hasConstraints() && this.needsValidation() && true === this.validationResult)\r\n      this._successClass();\r\n    else if (this.validationResult.length > 0)\r\n      this._errorClass();\r\n    else\r\n      this._resetClass();\r\n  },\r\n\r\n  _manageErrorsMessages: function (diff) {\r\n    if ('undefined' !== typeof this.options.errorsMessagesDisabled)\r\n      return;\r\n\r\n    // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\r\n    if ('undefined' !== typeof this.options.errorMessage) {\r\n      if ((diff.added.length || diff.kept.length)) {\r\n        this._insertErrorWrapper();\r\n\r\n        if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length)\r\n          this._ui.$errorsWrapper\r\n            .append(\r\n              $(this.options.errorTemplate)\r\n              .addClass('parsley-custom-error-message')\r\n            );\r\n\r\n        return this._ui.$errorsWrapper\r\n          .addClass('filled')\r\n          .find('.parsley-custom-error-message')\r\n          .html(this.options.errorMessage);\r\n      }\r\n\r\n      return this._ui.$errorsWrapper\r\n        .removeClass('filled')\r\n        .find('.parsley-custom-error-message')\r\n        .remove();\r\n    }\r\n\r\n    // Show, hide, update failing constraints messages\r\n    for (var i = 0; i < diff.removed.length; i++)\r\n      this._removeError(diff.removed[i].assert.name);\r\n\r\n    for (i = 0; i < diff.added.length; i++)\r\n      this._addError(diff.added[i].assert.name, {message: diff.added[i].errorMessage, assert: diff.added[i].assert});\r\n\r\n    for (i = 0; i < diff.kept.length; i++)\r\n      this._updateError(diff.kept[i].assert.name, {message: diff.kept[i].errorMessage, assert: diff.kept[i].assert});\r\n  },\r\n\r\n\r\n  _addError: function (name, {message, assert}) {\r\n    this._insertErrorWrapper();\r\n    this._ui.$errorsWrapper\r\n      .addClass('filled')\r\n      .append(\r\n        $(this.options.errorTemplate)\r\n        .addClass('parsley-' + name)\r\n        .html(message || this._getErrorMessage(assert))\r\n      );\r\n  },\r\n\r\n  _updateError: function (name, {message, assert}) {\r\n    this._ui.$errorsWrapper\r\n      .addClass('filled')\r\n      .find('.parsley-' + name)\r\n      .html(message || this._getErrorMessage(assert));\r\n  },\r\n\r\n  _removeError: function (name) {\r\n    this._ui.$errorsWrapper\r\n      .removeClass('filled')\r\n      .find('.parsley-' + name)\r\n      .remove();\r\n  },\r\n\r\n  _getErrorMessage: function (constraint) {\r\n    var customConstraintErrorMessage = constraint.name + 'Message';\r\n\r\n    if ('undefined' !== typeof this.options[customConstraintErrorMessage])\r\n      return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\r\n\r\n    return window.Parsley.getErrorMessage(constraint);\r\n  },\r\n\r\n  _buildUI: function () {\r\n    // UI could be already built or disabled\r\n    if (this._ui || false === this.options.uiEnabled)\r\n      return;\r\n\r\n    var _ui = {};\r\n\r\n    // Give field its Parsley id in DOM\r\n    this.element.setAttribute(this.options.namespace + 'id', this.__id__);\r\n\r\n    /** Generate important UI elements and store them in this **/\r\n    // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\r\n    _ui.$errorClassHandler = this._manageClassHandler();\r\n\r\n    // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\r\n    _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\r\n    _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\r\n\r\n    // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\r\n    _ui.lastValidationResult = [];\r\n    _ui.validationInformationVisible = false;\r\n\r\n    // Store it in this for later\r\n    this._ui = _ui;\r\n  },\r\n\r\n  // Determine which element will have `parsley-error` and `parsley-success` classes\r\n  _manageClassHandler: function () {\r\n    // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\r\n    if ('string' === typeof this.options.classHandler) {\r\n      if ($(this.options.classHandler).length === 0)\r\n        ParsleyUtils.warn('No elements found that match the selector `' + this.options.classHandler + '` set in options.classHandler or data-parsley-class-handler');\r\n\r\n      //return element or empty set\r\n      return $(this.options.classHandler);\r\n    }\r\n\r\n    // Class handled could also be determined by function given in Parsley options\r\n    if ('function' === typeof this.options.classHandler)\r\n      var $handler = this.options.classHandler.call(this, this);\r\n\r\n    // If this function returned a valid existing DOM element, go for it\r\n    if ('undefined' !== typeof $handler && $handler.length)\r\n      return $handler;\r\n\r\n    return this._inputHolder();\r\n  },\r\n\r\n  _inputHolder: function() {\r\n    // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\r\n    if (!this.options.multiple || this.element.nodeName === 'SELECT')\r\n      return this.$element;\r\n\r\n    // But if multiple element (radio, checkbox), that would be their parent\r\n    return this.$element.parent();\r\n  },\r\n\r\n  _insertErrorWrapper: function () {\r\n    var $errorsContainer;\r\n\r\n    // Nothing to do if already inserted\r\n    if (0 !== this._ui.$errorsWrapper.parent().length)\r\n      return this._ui.$errorsWrapper.parent();\r\n\r\n    if ('string' === typeof this.options.errorsContainer) {\r\n      if ($(this.options.errorsContainer).length)\r\n        return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);\r\n      else\r\n        Utils.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\r\n    } else if ('function' === typeof this.options.errorsContainer)\r\n      $errorsContainer = this.options.errorsContainer.call(this, this);\r\n\r\n    if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)\r\n      return $errorsContainer.append(this._ui.$errorsWrapper);\r\n\r\n    return this._inputHolder().after(this._ui.$errorsWrapper);\r\n  },\r\n\r\n  _actualizeTriggers: function () {\r\n    var $toBind = this._findRelated();\r\n    var trigger;\r\n\r\n    // Remove Parsley events already bound on this field\r\n    $toBind.off('.Parsley');\r\n    if (this._failedOnce)\r\n      $toBind.on(Utils.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), () => {\r\n        this._validateIfNeeded();\r\n      });\r\n    else if (trigger = Utils.namespaceEvents(this.options.trigger, 'Parsley')) {\r\n      $toBind.on(trigger, event => {\r\n        this._validateIfNeeded(event);\r\n      });\r\n    }\r\n  },\r\n\r\n  _validateIfNeeded: function (event) {\r\n    // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\r\n    // do not validate if val length < min threshold on first validation. Once field have been validated once and info\r\n    // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\r\n    if (event && /key|input/.test(event.type))\r\n      if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold)\r\n        return;\r\n\r\n    if (this.options.debounce) {\r\n      window.clearTimeout(this._debounced);\r\n      this._debounced = window.setTimeout(() => this.validate(), this.options.debounce);\r\n    } else\r\n      this.validate();\r\n  },\r\n\r\n  _resetUI: function () {\r\n    // Reset all event listeners\r\n    this._failedOnce = false;\r\n    this._actualizeTriggers();\r\n\r\n    // Nothing to do if UI never initialized for this field\r\n    if ('undefined' === typeof this._ui)\r\n      return;\r\n\r\n    // Reset all errors' li\r\n    this._ui.$errorsWrapper\r\n      .removeClass('filled')\r\n      .children()\r\n      .remove();\r\n\r\n    // Reset validation class\r\n    this._resetClass();\r\n\r\n    // Reset validation flags and last validation result\r\n    this._ui.lastValidationResult = [];\r\n    this._ui.validationInformationVisible = false;\r\n  },\r\n\r\n  _destroyUI: function () {\r\n    this._resetUI();\r\n\r\n    if ('undefined' !== typeof this._ui)\r\n      this._ui.$errorsWrapper.remove();\r\n\r\n    delete this._ui;\r\n  },\r\n\r\n  _successClass: function () {\r\n    this._ui.validationInformationVisible = true;\r\n    this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\r\n  },\r\n  _errorClass: function () {\r\n    this._ui.validationInformationVisible = true;\r\n    this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\r\n  },\r\n  _resetClass: function () {\r\n    this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\r\n  }\r\n};\r\n\r\nexport default UI;\r\n","import $ from 'jquery';\r\nimport Base from './base';\r\nimport Utils from './utils';\r\n\r\nvar Form = function (element, domOptions, options) {\r\n  this.__class__ = 'Form';\r\n\r\n  this.element = element;\r\n  this.$element = $(element);\r\n  this.domOptions = domOptions;\r\n  this.options = options;\r\n  this.parent = window.Parsley;\r\n\r\n  this.fields = [];\r\n  this.validationResult = null;\r\n};\r\n\r\nvar statusMapping = {pending: null, resolved: true, rejected: false};\r\n\r\nForm.prototype = {\r\n  onSubmitValidate: function (event) {\r\n    // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\r\n    if (true === event.parsley)\r\n      return;\r\n\r\n    // If we didn't come here through a submit button, use the first one in the form\r\n    var submitSource = this._submitSource || this.$element.find(Utils._SubmitSelector)[0];\r\n    this._submitSource = null;\r\n    this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\r\n    if (submitSource && null !== submitSource.getAttribute('formnovalidate'))\r\n      return;\r\n\r\n    window.Parsley._remoteCache = {};\r\n\r\n    var promise = this.whenValidate({event});\r\n\r\n    if ('resolved' === promise.state() && false !== this._trigger('submit')) {\r\n      // All good, let event go through. We make this distinction because browsers\r\n      // differ in their handling of `submit` being called from inside a submit event [#1047]\r\n    } else {\r\n      // Rejected or pending: cancel this submit\r\n      event.stopImmediatePropagation();\r\n      event.preventDefault();\r\n      if ('pending' === promise.state())\r\n        promise.done(() => { this._submit(submitSource); });\r\n    }\r\n  },\r\n\r\n  onSubmitButton: function(event) {\r\n    this._submitSource = event.currentTarget;\r\n  },\r\n  // internal\r\n  // _submit submits the form, this time without going through the validations.\r\n  // Care must be taken to \"fake\" the actual submit button being clicked.\r\n  _submit: function (submitSource) {\r\n    if (false === this._trigger('submit'))\r\n      return;\r\n    // Add submit button's data\r\n    if (submitSource) {\r\n      var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\r\n      if (0 === $synthetic.length)\r\n        $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\r\n      $synthetic.attr({\r\n        name: submitSource.getAttribute('name'),\r\n        value: submitSource.getAttribute('value')\r\n      });\r\n    }\r\n\r\n    this.$element.trigger(Object.assign($.Event('submit'), {parsley: true}));\r\n  },\r\n\r\n  // Performs validation on fields while triggering events.\r\n  // @returns `true` if all validations succeeds, `false`\r\n  // if a failure is immediately detected, or `null`\r\n  // if dependant on a promise.\r\n  // Consider using `whenValidate` instead.\r\n  validate: function (options) {\r\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n      Utils.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\r\n      var [group, force, silent, event] = arguments;\r\n      options = {group, force, silent, event};\r\n    }\r\n    return statusMapping[ this.whenValidate(options).state() ];\r\n  },\r\n\r\n  whenValidate: function ({group, force, silent, event} = {}) {\r\n    this.submitEvent = event;\r\n    if (event) {\r\n      this.submitEvent = Object.assign({}, event, {preventDefault: () => {\r\n        Utils.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\r\n        this.validationResult = false;\r\n      }});\r\n    }\r\n    this.validationResult = true;\r\n\r\n    // fire validate event to eventually modify things before every validation\r\n    this._trigger('validate');\r\n\r\n    // Refresh form DOM options and form's fields that could have changed\r\n    this._refreshFields();\r\n\r\n    var promises = this._withoutReactualizingFormOptions(() => {\r\n      return $.map(this.fields, field => field.whenValidate({force, group, silent}));\r\n    });\r\n\r\n    return Utils.all(promises)\r\n      .done(  () => { this._trigger('success'); })\r\n      .fail(  () => {\r\n        this.validationResult = false;\r\n        if (!silent) this.focus();\r\n        this._trigger('error');\r\n      })\r\n      .always(() => { this._trigger('validated'); })\r\n      .pipe(...this._pipeAccordingToValidationResult());\r\n  },\r\n\r\n  // Iterate over refreshed fields, and stop on first failure.\r\n  // Returns `true` if all fields are valid, `false` if a failure is detected\r\n  // or `null` if the result depends on an unresolved promise.\r\n  // Prefer using `whenValid` instead.\r\n  isValid: function (options) {\r\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n      Utils.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\r\n      var [group, force] = arguments;\r\n      options = {group, force};\r\n    }\r\n    return statusMapping[ this.whenValid(options).state() ];\r\n  },\r\n\r\n  // Iterate over refreshed fields and validate them.\r\n  // Returns a promise.\r\n  // A validation that immediately fails will interrupt the validations.\r\n  whenValid: function ({group, force} = {}) {\r\n    this._refreshFields();\r\n\r\n    var promises = this._withoutReactualizingFormOptions(() => {\r\n      return $.map(this.fields, field => field.whenValid({group, force}));\r\n    });\r\n    return Utils.all(promises);\r\n  },\r\n\r\n  // Reset UI\r\n  reset: function () {\r\n    // Form case: emit a reset event for each field\r\n    for (var i = 0; i < this.fields.length; i++)\r\n      this.fields[i].reset();\r\n\r\n    this._trigger('reset');\r\n  },\r\n\r\n  // Destroy Parsley instance (+ UI)\r\n  destroy: function () {\r\n    // Field case: emit destroy event to clean UI and then destroy stored instance\r\n    this._destroyUI();\r\n\r\n    // Form case: destroy all its fields and then destroy stored instance\r\n    for (var i = 0; i < this.fields.length; i++)\r\n      this.fields[i].destroy();\r\n\r\n    this.$element.removeData('Parsley');\r\n    this._trigger('destroy');\r\n  },\r\n\r\n  _refreshFields: function () {\r\n    return this.actualizeOptions()._bindFields();\r\n  },\r\n\r\n  _bindFields: function () {\r\n    var oldFields = this.fields;\r\n\r\n    this.fields = [];\r\n    this.fieldsMappedById = {};\r\n\r\n    this._withoutReactualizingFormOptions(() => {\r\n      this.$element\r\n      .find(this.options.inputs)\r\n      .not(this.options.excluded)\r\n      .each((_, element) => {\r\n        var fieldInstance = new window.Parsley.Factory(element, {}, this);\r\n\r\n        // Only add valid and not excluded `Field` and `FieldMultiple` children\r\n        if (('Field' === fieldInstance.__class__ || 'FieldMultiple' === fieldInstance.__class__) && (true !== fieldInstance.options.excluded)) {\r\n          let uniqueId = fieldInstance.__class__ + '-' + fieldInstance.__id__;\r\n          if ('undefined' === typeof this.fieldsMappedById[uniqueId]) {\r\n            this.fieldsMappedById[uniqueId] = fieldInstance;\r\n            this.fields.push(fieldInstance);\r\n          }\r\n        }\r\n      });\r\n\r\n      $.each(Utils.difference(oldFields, this.fields), (_, field) => {\r\n        field.reset();\r\n      });\r\n    });\r\n    return this;\r\n  },\r\n\r\n  // Internal only.\r\n  // Looping on a form's fields to do validation or similar\r\n  // will trigger reactualizing options on all of them, which\r\n  // in turn will reactualize the form's options.\r\n  // To avoid calling actualizeOptions so many times on the form\r\n  // for nothing, _withoutReactualizingFormOptions temporarily disables\r\n  // the method actualizeOptions on this form while `fn` is called.\r\n  _withoutReactualizingFormOptions: function (fn) {\r\n    var oldActualizeOptions = this.actualizeOptions;\r\n    this.actualizeOptions = function () { return this; };\r\n    var result = fn();\r\n    this.actualizeOptions = oldActualizeOptions;\r\n    return result;\r\n  },\r\n\r\n  // Internal only.\r\n  // Shortcut to trigger an event\r\n  // Returns true iff event is not interrupted and default not prevented.\r\n  _trigger: function (eventName) {\r\n    return this.trigger('form:' + eventName);\r\n  }\r\n\r\n};\r\n\r\nexport default Form;\r\n","import Utils from './utils';\r\nimport Validator from './validator';\r\n\r\nconst Constraint = function(parsleyField, name, requirements, priority, isDomConstraint) {\r\n  const validatorSpec = window.Parsley._validatorRegistry.validators[name];\r\n  const validator = new Validator(validatorSpec);\r\n  priority = priority || parsleyField.options[name + 'Priority'] || validator.priority;\r\n  isDomConstraint = (true === isDomConstraint);\r\n\r\n  Object.assign(this, {\r\n    validator,\r\n    name,\r\n    requirements,\r\n    priority,\r\n    isDomConstraint\r\n  });\r\n  this._parseRequirements(parsleyField.options);\r\n};\r\n\r\nconst capitalize = function(str) {\r\n  const cap = str[0].toUpperCase();\r\n  return cap + str.slice(1);\r\n};\r\n\r\nConstraint.prototype = {\r\n  validate: function(value, instance) {\r\n    return this.validator.validate(value, ...this.requirementList, instance);\r\n  },\r\n\r\n  _parseRequirements: function(options) {\r\n    this.requirementList = this.validator.parseRequirements(this.requirements,\r\n      key => options[this.name + capitalize(key)]\r\n    );\r\n  }\r\n};\r\n\r\nexport default Constraint;\r\n","import $ from 'jquery';\r\nimport Constraint from './constraint';\r\nimport UI from './ui';\r\nimport Utils from './utils';\r\n\r\nvar Field = function (field, domOptions, options, parsleyFormInstance) {\r\n  this.__class__ = 'Field';\r\n\r\n  this.element = field;\r\n  this.$element = $(field);\r\n\r\n  // Set parent if we have one\r\n  if ('undefined' !== typeof parsleyFormInstance) {\r\n    this.parent = parsleyFormInstance;\r\n  }\r\n\r\n  this.options = options;\r\n  this.domOptions = domOptions;\r\n\r\n  // Initialize some properties\r\n  this.constraints = [];\r\n  this.constraintsByName = {};\r\n  this.validationResult = true;\r\n\r\n  // Bind constraints\r\n  this._bindConstraints();\r\n};\r\n\r\nvar statusMapping = {pending: null, resolved: true, rejected: false};\r\n\r\nField.prototype = {\r\n  // # Public API\r\n  // Validate field and trigger some events for mainly `UI`\r\n  // @returns `true`, an array of the validators that failed, or\r\n  // `null` if validation is not finished. Prefer using whenValidate\r\n  validate: function (options) {\r\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n      Utils.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\r\n      options = {options};\r\n    }\r\n    var promise = this.whenValidate(options);\r\n    if (!promise)  // If excluded with `group` option\r\n      return true;\r\n    switch (promise.state()) {\r\n      case 'pending': return null;\r\n      case 'resolved': return true;\r\n      case 'rejected': return this.validationResult;\r\n    }\r\n  },\r\n\r\n  // Validate field and trigger some events for mainly `UI`\r\n  // @returns a promise that succeeds only when all validations do\r\n  // or `undefined` if field is not in the given `group`.\r\n  whenValidate: function ({force, group, silent} =  {}) {\r\n    // do not validate a field if not the same as given validation group\r\n    this.refreshConstraints();\r\n    if (group && !this._isInGroup(group))\r\n      return;\r\n\r\n    this.value = this.getValue();\r\n\r\n    // Field Validate event. `this.value` could be altered for custom needs\r\n    this._trigger('validate');\r\n\r\n    return this.whenValid({force, value: this.value, _refreshed: true})\r\n      .always(() => { this._reflowUI({silent}); })\r\n      .done(() =>   { this._trigger('success'); })\r\n      .fail(() =>   { this._trigger('error'); })\r\n      .always(() => { this._trigger('validated'); })\r\n      .pipe(...this._pipeAccordingToValidationResult());\r\n  },\r\n\r\n  hasConstraints: function () {\r\n    return 0 !== this.constraints.length;\r\n  },\r\n\r\n  // An empty optional field does not need validation\r\n  needsValidation: function (value) {\r\n    if ('undefined' === typeof value)\r\n      value = this.getValue();\r\n\r\n    // If a field is empty and not required, it is valid\r\n    // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\r\n    if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty)\r\n      return false;\r\n\r\n    return true;\r\n  },\r\n\r\n  _isInGroup: function (group) {\r\n    if (Array.isArray(this.options.group))\r\n      return -1 !== $.inArray(group, this.options.group);\r\n    return this.options.group === group;\r\n  },\r\n\r\n  // Just validate field. Do not trigger any event.\r\n  // Returns `true` iff all constraints pass, `false` if there are failures,\r\n  // or `null` if the result can not be determined yet (depends on a promise)\r\n  // See also `whenValid`.\r\n  isValid: function (options) {\r\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\r\n      Utils.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\r\n      var [force, value] = arguments;\r\n      options = {force, value};\r\n    }\r\n    var promise = this.whenValid(options);\r\n    if (!promise) // Excluded via `group`\r\n      return true;\r\n    return statusMapping[promise.state()];\r\n  },\r\n\r\n  // Just validate field. Do not trigger any event.\r\n  // @returns a promise that succeeds only when all validations do\r\n  // or `undefined` if the field is not in the given `group`.\r\n  // The argument `force` will force validation of empty fields.\r\n  // If a `value` is given, it will be validated instead of the value of the input.\r\n  whenValid: function ({force = false, value, group, _refreshed} = {}) {\r\n    // Recompute options and rebind constraints to have latest changes\r\n    if (!_refreshed)\r\n      this.refreshConstraints();\r\n    // do not validate a field if not the same as given validation group\r\n    if (group && !this._isInGroup(group))\r\n      return;\r\n\r\n    this.validationResult = true;\r\n\r\n    // A field without constraint is valid\r\n    if (!this.hasConstraints())\r\n      return $.when();\r\n\r\n    // Value could be passed as argument, needed to add more power to 'field:validate'\r\n    if ('undefined' === typeof value || null === value)\r\n      value = this.getValue();\r\n\r\n    if (!this.needsValidation(value) && true !== force)\r\n      return $.when();\r\n\r\n    var groupedConstraints = this._getGroupedConstraints();\r\n    var promises = [];\r\n    $.each(groupedConstraints, (_, constraints) => {\r\n      // Process one group of constraints at a time, we validate the constraints\r\n      // and combine the promises together.\r\n      var promise = Utils.all(\r\n        $.map(constraints, constraint => this._validateConstraint(value, constraint))\r\n      );\r\n      promises.push(promise);\r\n      if (promise.state() === 'rejected')\r\n        return false; // Interrupt processing if a group has already failed\r\n    });\r\n    return Utils.all(promises);\r\n  },\r\n\r\n  // @returns a promise\r\n  _validateConstraint: function(value, constraint) {\r\n    var result = constraint.validate(value, this);\r\n    // Map false to a failed promise\r\n    if (false === result)\r\n      result = $.Deferred().reject();\r\n    // Make sure we return a promise and that we record failures\r\n    return Utils.all([result]).fail(errorMessage => {\r\n      if (!(this.validationResult instanceof Array))\r\n        this.validationResult = [];\r\n      this.validationResult.push({\r\n        assert: constraint,\r\n        errorMessage: 'string' === typeof errorMessage && errorMessage\r\n      });\r\n    });\r\n  },\r\n\r\n  // @returns Parsley field computed value that could be overrided or configured in DOM\r\n  getValue: function () {\r\n    var value;\r\n\r\n    // Value could be overriden in DOM or with explicit options\r\n    if ('function' === typeof this.options.value)\r\n      value = this.options.value(this);\r\n    else if ('undefined' !== typeof this.options.value)\r\n      value = this.options.value;\r\n    else\r\n      value = this.$element.val();\r\n\r\n    // Handle wrong DOM or configurations\r\n    if ('undefined' === typeof value || null === value)\r\n      return '';\r\n\r\n    return this._handleWhitespace(value);\r\n  },\r\n\r\n  // Reset UI\r\n  reset: function () {\r\n    this._resetUI();\r\n    return this._trigger('reset');\r\n  },\r\n\r\n  // Destroy Parsley instance (+ UI)\r\n  destroy: function () {\r\n    // Field case: emit destroy event to clean UI and then destroy stored instance\r\n    this._destroyUI();\r\n    this.$element.removeData('Parsley');\r\n    this.$element.removeData('FieldMultiple');\r\n    this._trigger('destroy');\r\n  },\r\n\r\n  // Actualize options that could have change since previous validation\r\n  // Re-bind accordingly constraints (could be some new, removed or updated)\r\n  refreshConstraints: function () {\r\n    return this.actualizeOptions()._bindConstraints();\r\n  },\r\n\r\n  /**\r\n  * Add a new constraint to a field\r\n  *\r\n  * @param {String}   name\r\n  * @param {Mixed}    requirements      optional\r\n  * @param {Number}   priority          optional\r\n  * @param {Boolean}  isDomConstraint   optional\r\n  */\r\n  addConstraint: function (name, requirements, priority, isDomConstraint) {\r\n\r\n    if (window.Parsley._validatorRegistry.validators[name]) {\r\n      var constraint = new Constraint(this, name, requirements, priority, isDomConstraint);\r\n\r\n      // if constraint already exist, delete it and push new version\r\n      if ('undefined' !== this.constraintsByName[constraint.name])\r\n        this.removeConstraint(constraint.name);\r\n\r\n      this.constraints.push(constraint);\r\n      this.constraintsByName[constraint.name] = constraint;\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  // Remove a constraint\r\n  removeConstraint: function (name) {\r\n    for (var i = 0; i < this.constraints.length; i++)\r\n      if (name === this.constraints[i].name) {\r\n        this.constraints.splice(i, 1);\r\n        break;\r\n      }\r\n    delete this.constraintsByName[name];\r\n    return this;\r\n  },\r\n\r\n  // Update a constraint (Remove + re-add)\r\n  updateConstraint: function (name, parameters, priority) {\r\n    return this.removeConstraint(name)\r\n      .addConstraint(name, parameters, priority);\r\n  },\r\n\r\n  // # Internals\r\n\r\n  // Internal only.\r\n  // Bind constraints from config + options + DOM\r\n  _bindConstraints: function () {\r\n    var constraints = [];\r\n    var constraintsByName = {};\r\n\r\n    // clean all existing DOM constraints to only keep javascript user constraints\r\n    for (var i = 0; i < this.constraints.length; i++)\r\n      if (false === this.constraints[i].isDomConstraint) {\r\n        constraints.push(this.constraints[i]);\r\n        constraintsByName[this.constraints[i].name] = this.constraints[i];\r\n      }\r\n\r\n    this.constraints = constraints;\r\n    this.constraintsByName = constraintsByName;\r\n\r\n    // then re-add Parsley DOM-API constraints\r\n    for (var name in this.options)\r\n      this.addConstraint(name, this.options[name], undefined, true);\r\n\r\n    // finally, bind special HTML5 constraints\r\n    return this._bindHtml5Constraints();\r\n  },\r\n\r\n  // Internal only.\r\n  // Bind specific HTML5 constraints to be HTML5 compliant\r\n  _bindHtml5Constraints: function () {\r\n    // html5 required\r\n    if (null !== this.element.getAttribute('required'))\r\n      this.addConstraint('required', true, undefined, true);\r\n\r\n    // html5 pattern\r\n    if (null !== this.element.getAttribute('pattern'))\r\n      this.addConstraint('pattern', this.element.getAttribute('pattern'), undefined, true);\r\n\r\n    // range\r\n    let min = this.element.getAttribute('min');\r\n    let max = this.element.getAttribute('max');\r\n    if (null !== min && null !== max)\r\n      this.addConstraint('range', [min, max], undefined, true);\r\n\r\n    // HTML5 min\r\n    else if (null !== min)\r\n      this.addConstraint('min', min, undefined, true);\r\n\r\n    // HTML5 max\r\n    else if (null !== max)\r\n      this.addConstraint('max', max, undefined, true);\r\n\r\n\r\n    // length\r\n    if (null !== this.element.getAttribute('minlength') && null !== this.element.getAttribute('maxlength'))\r\n      this.addConstraint('length', [this.element.getAttribute('minlength'), this.element.getAttribute('maxlength')], undefined, true);\r\n\r\n    // HTML5 minlength\r\n    else if (null !== this.element.getAttribute('minlength'))\r\n      this.addConstraint('minlength', this.element.getAttribute('minlength'), undefined, true);\r\n\r\n    // HTML5 maxlength\r\n    else if (null !== this.element.getAttribute('maxlength'))\r\n      this.addConstraint('maxlength', this.element.getAttribute('maxlength'), undefined, true);\r\n\r\n\r\n    // html5 types\r\n    var type = this.element.type;\r\n\r\n    // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\r\n    if ('number' === type) {\r\n      return this.addConstraint('type', ['number', {\r\n        step: this.element.getAttribute('step') || '1',\r\n        base: min || this.element.getAttribute('value')\r\n      }], undefined, true);\r\n    // Regular other HTML5 supported types\r\n    } else if (/^(email|url|range|date)$/i.test(type)) {\r\n      return this.addConstraint('type', type, undefined, true);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  // Internal only.\r\n  // Field is required if have required constraint without `false` value\r\n  _isRequired: function () {\r\n    if ('undefined' === typeof this.constraintsByName.required)\r\n      return false;\r\n\r\n    return false !== this.constraintsByName.required.requirements;\r\n  },\r\n\r\n  // Internal only.\r\n  // Shortcut to trigger an event\r\n  _trigger: function (eventName) {\r\n    return this.trigger('field:' + eventName);\r\n  },\r\n\r\n  // Internal only\r\n  // Handles whitespace in a value\r\n  // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\r\n  // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\r\n  _handleWhitespace: function (value) {\r\n    if (true === this.options.trimValue)\r\n      Utils.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\r\n\r\n    if ('squish' === this.options.whitespace)\r\n      value = value.replace(/\\s{2,}/g, ' ');\r\n\r\n    if (('trim' === this.options.whitespace) || ('squish' === this.options.whitespace) || (true === this.options.trimValue))\r\n      value = Utils.trimString(value);\r\n\r\n    return value;\r\n  },\r\n\r\n  _isDateInput: function() {\r\n    var c = this.constraintsByName.type;\r\n    return c && c.requirements === 'date';\r\n  },\r\n\r\n  // Internal only.\r\n  // Returns the constraints, grouped by descending priority.\r\n  // The result is thus an array of arrays of constraints.\r\n  _getGroupedConstraints: function () {\r\n    if (false === this.options.priorityEnabled)\r\n      return [this.constraints];\r\n\r\n    var groupedConstraints = [];\r\n    var index = {};\r\n\r\n    // Create array unique of priorities\r\n    for (var i = 0; i < this.constraints.length; i++) {\r\n      var p = this.constraints[i].priority;\r\n      if (!index[p])\r\n        groupedConstraints.push(index[p] = []);\r\n      index[p].push(this.constraints[i]);\r\n    }\r\n    // Sort them by priority DESC\r\n    groupedConstraints.sort(function (a, b) { return b[0].priority - a[0].priority; });\r\n\r\n    return groupedConstraints;\r\n  }\r\n\r\n};\r\n\r\nexport default Field;\r\n","import $ from 'jquery';\r\n\r\nvar Multiple = function () {\r\n  this.__class__ = 'FieldMultiple';\r\n};\r\n\r\nMultiple.prototype = {\r\n  // Add new `$element` sibling for multiple field\r\n  addElement: function ($element) {\r\n    this.$elements.push($element);\r\n\r\n    return this;\r\n  },\r\n\r\n  // See `Field.refreshConstraints()`\r\n  refreshConstraints: function () {\r\n    var fieldConstraints;\r\n\r\n    this.constraints = [];\r\n\r\n    // Select multiple special treatment\r\n    if (this.element.nodeName === 'SELECT') {\r\n      this.actualizeOptions()._bindConstraints();\r\n\r\n      return this;\r\n    }\r\n\r\n    // Gather all constraints for each input in the multiple group\r\n    for (var i = 0; i < this.$elements.length; i++) {\r\n\r\n      // Check if element have not been dynamically removed since last binding\r\n      if (!$('html').has(this.$elements[i]).length) {\r\n        this.$elements.splice(i, 1);\r\n        continue;\r\n      }\r\n\r\n      fieldConstraints = this.$elements[i].data('FieldMultiple').refreshConstraints().constraints;\r\n\r\n      for (var j = 0; j < fieldConstraints.length; j++)\r\n        this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  // See `Field.getValue()`\r\n  getValue: function () {\r\n    // Value could be overriden in DOM\r\n    if ('function' === typeof this.options.value)\r\n      return this.options.value(this);\r\n    else if ('undefined' !== typeof this.options.value)\r\n      return this.options.value;\r\n\r\n    // Radio input case\r\n    if (this.element.nodeName === 'INPUT') {\r\n      if (this.element.type === 'radio')\r\n        return this._findRelated().filter(':checked').val() || '';\r\n\r\n      // checkbox input case\r\n      if (this.element.type === 'checkbox') {\r\n        var values = [];\r\n\r\n        this._findRelated().filter(':checked').each(function () {\r\n          values.push($(this).val());\r\n        });\r\n\r\n        return values;\r\n      }\r\n    }\r\n\r\n    // Select multiple case\r\n    if (this.element.nodeName === 'SELECT' && null === this.$element.val())\r\n      return [];\r\n\r\n    // Default case that should never happen\r\n    return this.$element.val();\r\n  },\r\n\r\n  _init: function () {\r\n    this.$elements = [this.$element];\r\n\r\n    return this;\r\n  }\r\n};\r\n\r\nexport default Multiple;\r\n","import $ from 'jquery';\r\nimport Utils from './utils';\r\nimport Base from './base';\r\nimport Form from './form';\r\nimport Field from './field';\r\nimport Multiple from './multiple';\r\n\r\nvar Factory = function (element, options, parsleyFormInstance) {\r\n  this.element = element;\r\n  this.$element = $(element);\r\n\r\n  // If the element has already been bound, returns its saved Parsley instance\r\n  var savedparsleyFormInstance = this.$element.data('Parsley');\r\n  if (savedparsleyFormInstance) {\r\n\r\n    // If the saved instance has been bound without a Form parent and there is one given in this call, add it\r\n    if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\r\n      savedparsleyFormInstance.parent = parsleyFormInstance;\r\n      savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\r\n    }\r\n\r\n    if ('object' === typeof options) {\r\n      Object.assign(savedparsleyFormInstance.options, options);\r\n    }\r\n\r\n    // return\r\n    return savedparsleyFormInstance;\r\n  }\r\n\r\n  // Parsley must be instantiated with a DOM element or jQuery $element\r\n  if (!this.$element.length)\r\n    throw new Error('You must bind Parsley on an existing element.');\r\n\r\n  if ('undefined' !== typeof parsleyFormInstance && 'Form' !== parsleyFormInstance.__class__)\r\n    throw new Error('Parent instance must be a Form instance');\r\n\r\n  this.parent = parsleyFormInstance || window.Parsley;\r\n\r\n  // return\r\n  return this.init(options);\r\n};\r\n\r\nFactory.prototype = {\r\n  init: function (options) {\r\n    this.__class__ = 'Parsley';\r\n    this.__version__ = '@@version';\r\n    this.__id__ = Utils.generateID();\r\n\r\n    // Pre-compute options\r\n    this._resetOptions(options);\r\n\r\n    // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\r\n    if (this.element.nodeName === 'FORM' || (Utils.checkAttr(this.element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))\r\n      return this.bind('parsleyForm');\r\n\r\n    // Every other element is bound as a `Field` or `FieldMultiple`\r\n    return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\r\n  },\r\n\r\n  isMultiple: function () {\r\n    return ((this.element.type === 'radio' || this.element.type === 'checkbox') ||\r\n      (this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple')));\r\n  },\r\n\r\n  // Multiples fields are a real nightmare :(\r\n  // Maybe some refactoring would be appreciated here...\r\n  handleMultiple: function () {\r\n    var name;\r\n    var multiple;\r\n    var parsleyMultipleInstance;\r\n\r\n    // Handle multiple name\r\n    this.options.multiple = this.options.multiple ||\r\n      (name = this.element.getAttribute('name')) ||\r\n      this.element.getAttribute('id');\r\n\r\n    // Special select multiple input\r\n    if (this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple')) {\r\n      this.options.multiple = this.options.multiple || this.__id__;\r\n      return this.bind('parsleyFieldMultiple');\r\n\r\n    // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\r\n    } else if (!this.options.multiple) {\r\n      Utils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\r\n      return this;\r\n    }\r\n\r\n    // Remove special chars\r\n    this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\r\n\r\n    // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\r\n    if (name) {\r\n      $('input[name=\"' + name + '\"]').each((i, input) => {\r\n        if ((input.type === 'radio' || input.type === 'checkbox'))\r\n          input.setAttribute(this.options.namespace + 'multiple', this.options.multiple);\r\n      });\r\n    }\r\n\r\n    // Check here if we don't already have a related multiple instance saved\r\n    var $previouslyRelated = this._findRelated();\r\n    for (var i = 0; i < $previouslyRelated.length; i++) {\r\n      parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\r\n      if ('undefined' !== typeof parsleyMultipleInstance) {\r\n\r\n        if (!this.$element.data('FieldMultiple')) {\r\n          parsleyMultipleInstance.addElement(this.$element);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`\r\n    // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance\r\n    this.bind('parsleyField', true);\r\n\r\n    return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\r\n  },\r\n\r\n  // Return proper `Form`, `Field` or `FieldMultiple`\r\n  bind: function (type, doNotStore) {\r\n    var parsleyInstance;\r\n\r\n    switch (type) {\r\n      case 'parsleyForm':\r\n        parsleyInstance = $.extend(\r\n          new Form(this.element, this.domOptions, this.options),\r\n          new Base(),\r\n          window.ParsleyExtend\r\n        )._bindFields();\r\n        break;\r\n      case 'parsleyField':\r\n        parsleyInstance = $.extend(\r\n          new Field(this.element, this.domOptions, this.options, this.parent),\r\n          new Base(),\r\n          window.ParsleyExtend\r\n        );\r\n        break;\r\n      case 'parsleyFieldMultiple':\r\n        parsleyInstance = $.extend(\r\n          new Field(this.element, this.domOptions, this.options, this.parent),\r\n          new Multiple(),\r\n          new Base(),\r\n          window.ParsleyExtend\r\n        )._init();\r\n        break;\r\n      default:\r\n        throw new Error(type + 'is not a supported Parsley type');\r\n    }\r\n\r\n    if (this.options.multiple)\r\n      Utils.setAttr(this.element, this.options.namespace, 'multiple', this.options.multiple);\r\n\r\n    if ('undefined' !== typeof doNotStore) {\r\n      this.$element.data('FieldMultiple', parsleyInstance);\r\n\r\n      return parsleyInstance;\r\n    }\r\n\r\n    // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\r\n    this.$element.data('Parsley', parsleyInstance);\r\n\r\n    // Tell the world we have a new Form or Field instance!\r\n    parsleyInstance._actualizeTriggers();\r\n    parsleyInstance._trigger('init');\r\n\r\n    return parsleyInstance;\r\n  }\r\n};\r\n\r\nexport default Factory;\r\n","import $ from 'jquery';\r\nimport Utils from './utils';\r\nimport Defaults from './defaults';\r\nimport Base from './base';\r\nimport ValidatorRegistry from './validator_registry';\r\nimport UI from './ui';\r\nimport Form from './form';\r\nimport Field from './field';\r\nimport Multiple from './multiple';\r\nimport Factory from './factory';\r\n\r\nvar vernums = $.fn.jquery.split('.');\r\nif (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\r\n  throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\r\n}\r\nif (!vernums.forEach) {\r\n  Utils.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\r\n}\r\n// Inherit `on`, `off` & `trigger` to Parsley:\r\nvar Parsley = Object.assign(new Base(), {\r\n    element: document,\r\n    $element: $(document),\r\n    actualizeOptions: null,\r\n    _resetOptions: null,\r\n    Factory: Factory,\r\n    version: '@@version'\r\n  });\r\n\r\n// Supplement Field and Form with Base\r\n// This way, the constructors will have access to those methods\r\nObject.assign(Field.prototype, UI.Field, Base.prototype);\r\nObject.assign(Form.prototype, UI.Form, Base.prototype);\r\n// Inherit actualizeOptions and _resetOptions:\r\nObject.assign(Factory.prototype, Base.prototype);\r\n\r\n// ### jQuery API\r\n// `$('.elem').parsley(options)` or `$('.elem').psly(options)`\r\n$.fn.parsley = $.fn.psly = function (options) {\r\n  if (this.length > 1) {\r\n    var instances = [];\r\n\r\n    this.each(function () {\r\n      instances.push($(this).parsley(options));\r\n    });\r\n\r\n    return instances;\r\n  }\r\n\r\n  // Return undefined if applied to non existing DOM element\r\n  if (!$(this).length) {\r\n    Utils.warn('You must bind Parsley on an existing element.');\r\n\r\n    return;\r\n  }\r\n\r\n  return new Factory(this[0], options);\r\n};\r\n\r\n// ### Field and Form extension\r\n// Ensure the extension is now defined if it wasn't previously\r\nif ('undefined' === typeof window.ParsleyExtend)\r\n  window.ParsleyExtend = {};\r\n\r\n// ### Parsley config\r\n// Inherit from ParsleyDefault, and copy over any existing values\r\nParsley.options = Object.assign(Utils.objectCreate(Defaults), window.ParsleyConfig);\r\nwindow.ParsleyConfig = Parsley.options; // Old way of accessing global options\r\n\r\n// ### Globals\r\nwindow.Parsley = window.psly = Parsley;\r\nParsley.Utils = Utils;\r\nwindow.ParsleyUtils = {};\r\n$.each(Utils, (key, value) => {\r\n  if ('function' === typeof value) {\r\n    window.ParsleyUtils[key] = (...args) => {\r\n      Utils.warnOnce('Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.');\r\n      return Utils[key](...args);\r\n    };\r\n  }\r\n});\r\n\r\n// ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\r\nvar registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\r\nwindow.ParsleyValidator = {};\r\n$.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\r\n  window.Parsley[method] = (...args) => registry[method](...args);\r\n  window.ParsleyValidator[method] = function () {\r\n    Utils.warnOnce(`Accessing the method '${method}' through Validator is deprecated. Simply call 'window.Parsley.${method}(...)'`);\r\n    return window.Parsley[method](...arguments);\r\n  };\r\n});\r\n\r\n// ### UI\r\n// Deprecated global object\r\nwindow.Parsley.UI = UI;\r\nwindow.ParsleyUI = {\r\n  removeError: function (instance, name, doNotUpdateClass) {\r\n    var updateClass = true !== doNotUpdateClass;\r\n    Utils.warnOnce(`Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\r\n    return instance.removeError(name, {updateClass});\r\n  },\r\n  getErrorsMessages: function (instance) {\r\n    Utils.warnOnce(`Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly.`);\r\n    return instance.getErrorsMessages();\r\n  }\r\n};\r\n$.each('addError updateError'.split(' '), function (i, method) {\r\n  window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\r\n    var updateClass = true !== doNotUpdateClass;\r\n    Utils.warnOnce(`Accessing UI is deprecated. Call '${method}' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\r\n    return instance[method](name, {message, assert, updateClass});\r\n  };\r\n});\r\n\r\n// ### PARSLEY auto-binding\r\n// Prevent it by setting `ParsleyConfig.autoBind` to `false`\r\nif (false !== window.ParsleyConfig.autoBind) {\r\n  $(function () {\r\n    // Works only on `data-parsley-validate`.\r\n    if ($('[data-parsley-validate]').length)\r\n      $('[data-parsley-validate]').parsley();\r\n  });\r\n}\r\n\r\nexport default Parsley;\r\n","import $ from 'jquery';\r\nimport Utils from './utils';\r\nimport Base from './base';\r\n\r\nimport Parsley from './main';\r\n\r\n$.extend(true, Parsley, {\r\n  asyncValidators: {\r\n    'default': {\r\n      fn: function (xhr) {\r\n        // By default, only status 2xx are deemed successful.\r\n        // Note: we use status instead of state() because responses with status 200\r\n        // but invalid messages (e.g. an empty body for content type set to JSON) will\r\n        // result in state() === 'rejected'.\r\n        return xhr.status >= 200 && xhr.status < 300;\r\n      },\r\n      url: false\r\n    },\r\n    reverse: {\r\n      fn: function (xhr) {\r\n        // If reverse option is set, a failing ajax request is considered successful\r\n        return xhr.status < 200 || xhr.status >= 300;\r\n      },\r\n      url: false\r\n    }\r\n  },\r\n\r\n  addAsyncValidator: function (name, fn, url, options) {\r\n    Parsley.asyncValidators[name] = {\r\n      fn: fn,\r\n      url: url || false,\r\n      options: options || {}\r\n    };\r\n\r\n    return this;\r\n  }\r\n\r\n});\r\n\r\nParsley.addValidator('remote', {\r\n  requirementType: {\r\n    '': 'string',\r\n    'validator': 'string',\r\n    'reverse': 'boolean',\r\n    'options': 'object'\r\n  },\r\n\r\n  validateString: function (value, url, options, instance) {\r\n    var data = {};\r\n    var ajaxOptions;\r\n    var csr;\r\n    var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\r\n\r\n    if ('undefined' === typeof Parsley.asyncValidators[validator])\r\n      throw new Error('Calling an undefined async validator: `' + validator + '`');\r\n\r\n    url = Parsley.asyncValidators[validator].url || url;\r\n\r\n    // Fill current value\r\n    if (url.indexOf('{value}') > -1) {\r\n      url = url.replace('{value}', encodeURIComponent(value));\r\n    } else {\r\n      data[instance.element.getAttribute('name') || instance.element.getAttribute('id')] = value;\r\n    }\r\n\r\n    // Merge options passed in from the function with the ones in the attribute\r\n    var remoteOptions = $.extend(true, options.options || {} , Parsley.asyncValidators[validator].options);\r\n\r\n    // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\r\n    ajaxOptions = $.extend(true, {}, {\r\n      url: url,\r\n      data: data,\r\n      type: 'GET'\r\n    }, remoteOptions);\r\n\r\n    // Generate store key based on ajax options\r\n    instance.trigger('field:ajaxoptions', instance, ajaxOptions);\r\n\r\n    csr = $.param(ajaxOptions);\r\n\r\n    // Initialise querry cache\r\n    if ('undefined' === typeof Parsley._remoteCache)\r\n      Parsley._remoteCache = {};\r\n\r\n    // Try to retrieve stored xhr\r\n    var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\r\n\r\n    var handleXhr = function () {\r\n      var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\r\n      if (!result) // Map falsy results to rejected promise\r\n        result = $.Deferred().reject();\r\n      return $.when(result);\r\n    };\r\n\r\n    return xhr.then(handleXhr, handleXhr);\r\n  },\r\n\r\n  priority: -1\r\n});\r\n\r\nParsley.on('form:submit', function () {\r\n  Parsley._remoteCache = {};\r\n});\r\n\r\nBase.prototype.addAsyncValidator = function () {\r\n  Utils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\r\n  return Parsley.addAsyncValidator(...arguments);\r\n};\r\n","// This is included with the Parsley library itself,\r\n// thus there is no use in adding it to your project.\r\nimport Parsley from '../parsley/main';\r\n\r\nParsley.addMessages('en', {\r\n  defaultMessage: \"This value seems to be invalid.\",\r\n  type: {\r\n    email:        \"This value should be a valid email.\",\r\n    url:          \"This value should be a valid url.\",\r\n    number:       \"This value should be a valid number.\",\r\n    integer:      \"This value should be a valid integer.\",\r\n    digits:       \"This value should be digits.\",\r\n    alphanum:     \"This value should be alphanumeric.\"\r\n  },\r\n  notblank:       \"This value should not be blank.\",\r\n  required:       \"This value is required.\",\r\n  pattern:        \"This value seems to be invalid.\",\r\n  min:            \"This value should be greater than or equal to %s.\",\r\n  max:            \"This value should be lower than or equal to %s.\",\r\n  range:          \"This value should be between %s and %s.\",\r\n  minlength:      \"This value is too short. It should have %s characters or more.\",\r\n  maxlength:      \"This value is too long. It should have %s characters or fewer.\",\r\n  length:         \"This value length is invalid. It should be between %s and %s characters long.\",\r\n  mincheck:       \"You must select at least %s choices.\",\r\n  maxcheck:       \"You must select %s choices or fewer.\",\r\n  check:          \"You must select between %s and %s choices.\",\r\n  equalto:        \"This value should be the same.\"\r\n});\r\n\r\nParsley.setLocale('en');\r\n","import $ from 'jquery';\r\nimport Parsley from './parsley/main';\r\nimport './parsley/pubsub';\r\nimport './parsley/remote';\r\nimport './i18n/en';\r\nimport inputevent from './vendor/inputevent';\r\n\r\ninputevent.install();\r\n\r\nexport default Parsley;\r\n"]}